[STDOUT] 
> litong-electronics-website@0.1.0 build
> npm run clear-cache && next build && npm run fix-static-export

[STDOUT] 
> litong-electronics-website@0.1.0 clear-cache
> node scripts/clear-cache.js

[STDOUT] 🧹 Clearing Next.js caches...
[STDOUT] ✅ Deleted C:\Users\ymlt\Desktop\litong\.next
[STDOUT] ℹ️  C:\Users\ymlt\Desktop\litong\node_modules\.cache does not exist
[STDOUT] ✅ Cache cleared! Please restart your development server.
Run: npm run dev
[STDOUT]   ▲ Next.js 14.2.32
[STDOUT]   - Environments: .env.local
[STDOUT] 
[STDOUT]    Creating an optimized production build ...
[STDOUT]  ✓ Compiled successfully
[STDOUT]    Skipping validation of types
[STDOUT]    Skipping linting
[STDOUT]    Collecting page data ...
[STDOUT] 😨 使用最小静态生成修复部署超时
[STDOUT] 🔍 [getAllBrands] Starting brand data fetch from Sanity...
[STDOUT] 🔍 [getAllBrands] Executing Sanity query...
[STDOUT] 🔍 [getAllBrands] Starting brand data fetch from Sanity...
[STDOUT] 🔍 [getAllBrands] Executing Sanity query...
[STDOUT] 🔍 [getAllBrands] Sanity query returned: 13 brands
[STDOUT] Generated static params for brand articles: 28
[STDOUT] 🔍 [getAllBrands] Sanity query returned: 13 brands
[STDOUT] Generated static params for brand products: 28
[STDOUT] 🔧 Generating brand product static parameters...
[STDOUT] 🔧 [getBrandProductCombinations] Fetching real brand-product combinations from Sanity...
[STDOUT] 🔍 [getAllBrands] Starting brand data fetch from Sanity...
[STDOUT] 🔍 [getAllBrands] Executing Sanity query...
[STDOUT] 🔍 [getAllBrands] Sanity query returned: 13 brands
[STDOUT] Generated static params for brand solutions: 28
[STDOUT] Generated static params for brands: 28
[STDOUT] 🔍 [getAllBrands] Starting brand data fetch from Sanity...
[STDOUT] 🔍 [getAllBrands] Executing Sanity query...
[STDOUT] 🔍 [getAllBrands] Sanity query returned: 13 brands
[STDOUT] Generated static params for brand support: 84
[STDOUT] Generated static params for solutions: 24
[STDOUT] 🔍 [getAllBrands] Starting brand data fetch from Sanity...
[STDOUT] 🔍 [getAllBrands] Executing Sanity query...
[STDOUT] 🔍 [getAllBrands] Sanity query returned: 13 brands
[STDOUT] Generated static params for brand support: 28
[STDOUT] ✅ [getBrandProductCombinations] Found combinations: {
  total: 12,
  combinations: [
    { brandSlug: 'Electronicon', productSlug: '99999' },
    { brandSlug: 'Electronicon', productSlug: '33333' },
    { brandSlug: 'cree', productSlug: 'sic mosfet' },
    { brandSlug: 'cree', productSlug: '55555' },
    { brandSlug: 'cree', productSlug: '11111' }
  ]
}
[STDOUT] 📋 Adding static param: zh-CN/Electronicon/99999
📋 Adding static param: zh-CN/Electronicon/33333
📋 Adding static param: zh-CN/cree/sic mosfet
📋 Adding static param: zh-CN/cree/55555
📋 Adding static param: zh-CN/cree/11111
📋 Adding static param: zh-CN/cree/c4d02120a
[STDOUT] 📋 Adding static param: zh-CN/lem/la55-p
[STDOUT] 📋 Adding static param: zh-CN/lem/la35-p
📋 Adding static param: zh-CN/lem/la25-p
[STDOUT] 📋 Adding static param: zh-CN/semikron/SKKT106/16E
📋 Adding static param: zh-CN/stmicroelectronics/stm32f407vgt6
[STDOUT] 📋 Adding static param: zh-CN/ti/opa2134pa
[STDOUT] 📋 Adding static param: en/Electronicon/99999
📋 Adding static param: en/Electronicon/33333
[STDOUT] 📋 Adding static param: en/cree/sic mosfet
📋 Adding static param: en/cree/55555
[STDOUT] 📋 Adding static param: en/cree/11111
📋 Adding static param: en/cree/c4d02120a
📋 Adding static param: en/lem/la55-p
📋 Adding static param: en/lem/la35-p
📋 Adding static param: en/lem/la25-p
📋 Adding static param: en/semikron/SKKT106/16E
[STDOUT] 📋 Adding static param: en/stmicroelectronics/stm32f407vgt6
📋 Adding static param: en/ti/opa2134pa
✅ Generated 24 brand product static params from 12 combinations
[STDOUT] 📊 Sample generated params: [
  { locale: 'zh-CN', slug: 'Electronicon', id: '99999' },
  { locale: 'zh-CN', slug: 'Electronicon', id: '33333' },
  { locale: 'zh-CN', slug: 'cree', id: 'sic mosfet' }
]
[STDOUT] 🔧 Generating brand solution static parameters...
[STDOUT] Generated static params for products: 28
[STDOUT] 🔍 Found brand-solution combinations: 7
[STDOUT] 📦 Generated static params for brand solutions: 14
[STDOUT] Generated static params for articles: 12
[STDOUT]    Generating static pages (0/359) ...
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: infineon
🔍 [getBrandData] Searching for brand with slug: infineon
[STDOUT] ✅ [getBrandData] Found brand: CREE
✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ti
🔍 [getBrandData] Searching for brand with slug: ti
[STDOUT] 🔍 [getBrandData] No exact match found, trying relaxed search for: infineon
🔍 [getBrandData] No exact match found, trying relaxed search for: infineon
[STDOUT] 🔍 [getBrandData] No exact match found, trying relaxed search for: ti
🔍 [getBrandData] No exact match found, trying relaxed search for: ti
[STDERR] ❌ [getBrandData] Brand not found for slug: infineon
❌ [getBrandData] Brand not found for slug: infineon
Brand or article not found for slug: infineon, id: aaaaa
Brand or article not found for slug: infineon, id: aaaaa
[STDERR] Brand or article not found for slug: cree, id: aaaaa
Brand or article not found for slug: cree, id: aaaaa
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
🔍 [getBrandData] Searching for brand with slug: cree
✅ [getBrandData] Found brand: CREE
✅ [getBrandData] Found brand: CREE
[STDERR] Brand or article not found for slug: cree, id: aaaaa
Brand or article not found for slug: cree, id: aaaaa
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: infineon
🔍 [getBrandData] Searching for brand with slug: infineon
🔍 [getBrandData] No exact match found, trying relaxed search for: infineon
🔍 [getBrandData] No exact match found, trying relaxed search for: infineon
[STDERR] ❌ [getBrandData] Brand not found for slug: ti
❌ [getBrandData] Brand not found for slug: ti
Brand or article not found for slug: ti, id: aaaaa
Brand or article not found for slug: ti, id: aaaaa
[STDERR] ❌ [getBrandData] Brand not found for slug: infineon
Brand or article not found for slug: infineon, id: aaaaa
❌ [getBrandData] Brand not found for slug: infineon
Brand or article not found for slug: infineon, id: aaaaa
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
✅ [getBrandData] Found brand: CREE
🔍 [getBrandData] Searching for brand with slug: cree
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: epcos
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
[STDOUT] Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
[STDOUT] ✅ [getBrandData] Found brand: Electronicon
✅ [getBrandData] Found brand: Electronicon
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
[STDOUT] Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
[STDOUT] ✅ [getBrandData] Found brand: Epcos
✅ [getBrandData] Found brand: Epcos
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] ✅ [getBrandData] Found brand: IXYS
✅ [getBrandData] Found brand: IXYS
[STDOUT] ✅ [getBrandData] Found brand: LEM
✅ [getBrandData] Found brand: LEM
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
[STDOUT] ✅ [getBrandData] Found brand: Littelfuse
✅ [getBrandData] Found brand: Littelfuse
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: mediatek
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: pi
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: MediaTek
✅ [getBrandData] Found brand: MediaTek
[STDOUT] ✅ [getBrandData] Found brand: PI
✅ [getBrandData] Found brand: PI
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] ✅ [getBrandData] Found brand: Qualcomm
✅ [getBrandData] Found brand: Qualcomm
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
✅ [getBrandData] Found brand: Semikron
✅ [getBrandData] Found brand: Semikron
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Sanrex
✅ [getBrandData] Found brand: Sanrex
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] ✅ [getBrandData] Found brand: ncc
✅ [getBrandData] Found brand: ncc
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
✅ [getBrandData] Found brand: CREE
Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
🔍 [getBrandData] Searching for brand with slug: cree
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
✅ [getBrandData] Found brand: CREE
Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
[STDOUT] ✅ [getBrandData] Found brand: 英飞凌
✅ [getBrandData] Found brand: 英飞凌
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
✅ [getBrandData] Found brand: Electronicon
✅ [getBrandData] Found brand: Electronicon
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: epcos
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
✅ [getBrandData] Found brand: Epcos
✅ [getBrandData] Found brand: Epcos
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
✅ [getBrandData] Found brand: IXYS
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
✅ [getBrandData] Found brand: IXYS
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
✅ [getBrandData] Found brand: Littelfuse
✅ [getBrandData] Found brand: Littelfuse
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
✅ [getBrandData] Found brand: LEM
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
✅ [getBrandData] Found brand: LEM
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
✅ [getBrandData] Found brand: MediaTek
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: mediatek
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
✅ [getBrandData] Found brand: MediaTek
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: pi
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
✅ [getBrandData] Found brand: PI
✅ [getBrandData] Found brand: PI
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
✅ [getBrandData] Found brand: Qualcomm
✅ [getBrandData] Found brand: Qualcomm
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
✅ [getBrandData] Found brand: Sanrex
✅ [getBrandData] Found brand: Sanrex
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
✅ [getBrandData] Found brand: Semikron
Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
✅ [getBrandData] Found brand: Semikron
Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
✅ [getBrandData] Found brand: ncc
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
✅ [getBrandData] Found brand: ncc
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
✅ [getBrandData] Found brand: 英飞凌
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
✅ [getBrandData] Found brand: 英飞凌
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
✅ [getBrandData] Found brand: CREE
🔍 [getBrandData] Searching for brand with slug: cree
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
✅ [getBrandData] Found brand: CREE
Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
✅ [getBrandData] Found brand: Electronicon
Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
✅ [getBrandData] Found brand: Electronicon
Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: epcos
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
✅ [getBrandData] Found brand: Epcos
✅ [getBrandData] Found brand: Epcos
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
✅ [getBrandData] Found brand: IXYS
✅ [getBrandData] Found brand: IXYS
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
✅ [getBrandData] Found brand: LEM
✅ [getBrandData] Found brand: LEM
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
✅ [getBrandData] Found brand: MediaTek
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: mediatek
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
✅ [getBrandData] Found brand: MediaTek
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
✅ [getBrandData] Found brand: Littelfuse
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
✅ [getBrandData] Found brand: Littelfuse
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: pi
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
✅ [getBrandData] Found brand: PI
✅ [getBrandData] Found brand: PI
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
✅ [getBrandData] Found brand: Sanrex
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
✅ [getBrandData] Found brand: Sanrex
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
✅ [getBrandData] Found brand: Qualcomm
✅ [getBrandData] Found brand: Qualcomm
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
✅ [getBrandData] Found brand: Semikron
✅ [getBrandData] Found brand: Semikron
Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
✅ [getBrandData] Found brand: ncc
✅ [getBrandData] Found brand: ncc
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
✅ [getBrandData] Found brand: 英飞凌
✅ [getBrandData] Found brand: 英飞凌
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: cree
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
✅ [getBrandData] Found brand: CREE
✅ [getBrandData] Found brand: CREE
Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
✅ [getBrandData] Found brand: Electronicon
Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
✅ [getBrandData] Found brand: Electronicon
Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
✅ [getBrandData] Found brand: Epcos
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: epcos
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
✅ [getBrandData] Found brand: Epcos
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
✅ [getBrandData] Found brand: IXYS
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
✅ [getBrandData] Found brand: IXYS
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
✅ [getBrandData] Found brand: LEM
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
✅ [getBrandData] Found brand: LEM
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
✅ [getBrandData] Found brand: Littelfuse
✅ [getBrandData] Found brand: Littelfuse
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
✅ [getBrandData] Found brand: Qualcomm
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
✅ [getBrandData] Found brand: Qualcomm
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: mediatek
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
✅ [getBrandData] Found brand: MediaTek
✅ [getBrandData] Found brand: MediaTek
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
✅ [getBrandData] Found brand: PI
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: pi
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
✅ [getBrandData] Found brand: PI
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
✅ [getBrandData] Found brand: Sanrex
✅ [getBrandData] Found brand: Sanrex
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
✅ [getBrandData] Found brand: Semikron
✅ [getBrandData] Found brand: Semikron
Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
✅ [getBrandData] Found brand: ncc
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
✅ [getBrandData] Found brand: ncc
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
✅ [getBrandData] Found brand: 英飞凌
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
✅ [getBrandData] Found brand: 英飞凌
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
[STDOUT] Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Epcos
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
✅ [getBrandData] Found brand: CREE
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
[STDOUT] Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Epcos
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
✅ [getBrandData] Found brand: IXYS
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
✅ [getBrandData] Found brand: IXYS
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
✅ [getBrandData] Found brand: Electronicon
Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
✅ [getBrandData] Found brand: Electronicon
Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
✅ [getBrandData] Found brand: Littelfuse
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
✅ [getBrandData] Found brand: Littelfuse
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
✅ [getBrandData] Found brand: LEM
✅ [getBrandData] Found brand: LEM
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
✅ [getBrandData] Found brand: MediaTek
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: mediatek
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
✅ [getBrandData] Found brand: MediaTek
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
✅ [getBrandData] Found brand: Qualcomm
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
✅ [getBrandData] Found brand: Qualcomm
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
✅ [getBrandData] Found brand: PI
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: pi
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
✅ [getBrandData] Found brand: PI
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
✅ [getBrandData] Found brand: Semikron
Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
✅ [getBrandData] Found brand: Semikron
Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
✅ [getBrandData] Found brand: Sanrex
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
✅ [getBrandData] Found brand: Sanrex
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
✅ [getBrandData] Found brand: ncc
✅ [getBrandData] Found brand: ncc
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
✅ [getBrandData] Found brand: 英飞凌
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
✅ [getBrandData] Found brand: 英飞凌
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
✅ [getBrandData] Found brand: CREE
Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
🔍 [getBrandData] Searching for brand with slug: cree
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
✅ [getBrandData] Found brand: CREE
Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
✅ [getBrandData] Found brand: Electronicon
Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
✅ [getBrandData] Found brand: Electronicon
Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
✅ [getBrandData] Found brand: IXYS
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
✅ [getBrandData] Found brand: IXYS
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
✅ [getBrandData] Found brand: Epcos
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: epcos
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
✅ [getBrandData] Found brand: Epcos
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
✅ [getBrandData] Found brand: LEM
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
✅ [getBrandData] Found brand: LEM
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
✅ [getBrandData] Found brand: Littelfuse
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
✅ [getBrandData] Found brand: Littelfuse
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: mediatek
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
✅ [getBrandData] Found brand: MediaTek
✅ [getBrandData] Found brand: MediaTek
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
✅ [getBrandData] Found brand: PI
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: pi
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
✅ [getBrandData] Found brand: PI
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
✅ [getBrandData] Found brand: Sanrex
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
✅ [getBrandData] Found brand: Sanrex
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
✅ [getBrandData] Found brand: Qualcomm
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
✅ [getBrandData] Found brand: Qualcomm
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
✅ [getBrandData] Found brand: Semikron
Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
✅ [getBrandData] Found brand: Semikron
Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT]    Generating static pages (89/359) 
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
✅ [getBrandData] Found brand: 英飞凌
✅ [getBrandData] Found brand: 英飞凌
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
✅ [getBrandData] Found brand: ncc
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
✅ [getBrandData] Found brand: ncc
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
✅ [getBrandData] Found brand: CREE
Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
🔍 [getBrandData] Searching for brand with slug: cree
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
✅ [getBrandData] Found brand: CREE
Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
✅ [getBrandData] Found brand: Electronicon
Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
✅ [getBrandData] Found brand: Electronicon
Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
✅ [getBrandData] Found brand: Epcos
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: epcos
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
✅ [getBrandData] Found brand: Epcos
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
✅ [getBrandData] Found brand: IXYS
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
✅ [getBrandData] Found brand: IXYS
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
✅ [getBrandData] Found brand: LEM
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
✅ [getBrandData] Found brand: LEM
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
✅ [getBrandData] Found brand: Littelfuse
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
✅ [getBrandData] Found brand: Littelfuse
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
✅ [getBrandData] Found brand: MediaTek
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: mediatek
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
✅ [getBrandData] Found brand: MediaTek
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
✅ [getBrandData] Found brand: PI
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: pi
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
✅ [getBrandData] Found brand: PI
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
✅ [getBrandData] Found brand: Qualcomm
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
✅ [getBrandData] Found brand: Qualcomm
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
✅ [getBrandData] Found brand: Sanrex
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
✅ [getBrandData] Found brand: Sanrex
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
✅ [getBrandData] Found brand: Semikron
Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
✅ [getBrandData] Found brand: Semikron
Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
✅ [getBrandData] Found brand: 英飞凌
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
✅ [getBrandData] Found brand: 英飞凌
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
✅ [getBrandData] Found brand: ncc
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
✅ [getBrandData] Found brand: ncc
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
✅ [getBrandData] Found brand: CREE
Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
🔍 [getBrandData] Searching for brand with slug: cree
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
✅ [getBrandData] Found brand: CREE
Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
🔍 [getBrandData] Searching for brand with slug: Electronicon
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
✅ [getBrandData] Found brand: Electronicon
✅ [getBrandData] Found brand: Electronicon
Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
✅ [getBrandData] Found brand: Epcos
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: epcos
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
✅ [getBrandData] Found brand: Epcos
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
✅ [getBrandData] Found brand: IXYS
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
🔍 [getBrandData] Searching for brand with slug: ixys
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
✅ [getBrandData] Found brand: IXYS
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
✅ [getBrandData] Found brand: LEM
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: lem
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
✅ [getBrandData] Found brand: LEM
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: MediaTek
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: PI
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: MediaTek
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] ✅ [getBrandData] Found brand: PI
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
✅ [getBrandData] Found brand: Littelfuse
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: littelfuse
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
✅ [getBrandData] Found brand: Littelfuse
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
✅ [getBrandData] Found brand: Sanrex
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: sanrex
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
✅ [getBrandData] Found brand: Sanrex
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
✅ [getBrandData] Found brand: Qualcomm
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: qualcomm
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
✅ [getBrandData] Found brand: Qualcomm
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
✅ [getBrandData] Found brand: Semikron
Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: semikron
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
✅ [getBrandData] Found brand: Semikron
Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
✅ [getBrandData] Found brand: ncc
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: ncc
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
✅ [getBrandData] Found brand: ncc
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
✅ [getBrandData] Found brand: 英飞凌
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: 英飞凌
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
✅ [getBrandData] Found brand: 英飞凌
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
[STDOUT] 📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
[STDOUT] 📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
[STDOUT] 📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
[STDOUT] 📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
[STDOUT] 📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
[STDOUT] 📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
[STDOUT] 📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
[STDOUT] 🔍 执行品牌查询: {
  '查询条件': '_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))',
  'GROQ查询': '\n' +
    '    *[_type == "brandBasic" && isActive == true && !(_id in path("drafts.**"))] | order(name asc) {\n' +
    '      \n' +
    '    _id,\n' +
    '    name,\n' +
    '    "slug": slug.current,\n' +
    '    logo,\n' +
    '    description,\n' +
    '    website,\n' +
    '    country,\n' +
    '    isActive,\n' +
    '    isFeatured\n' +
    '  \n' +
    '    }\n' +
    '  ',
  '是否仅获取推荐': false
}
[STDOUT] 📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 📊 品牌查询结果: {
  '数量': 13,
  '品牌列表': [
    {
      id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      '名称': 'CREE',
      slug: 'cree',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '334583a0-df48-4c3f-909f-8e700606a877',
      '名称': 'Electronicon',
      slug: 'Electronicon',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '25b7d701-24ff-4287-87d2-2ea7a275c2f4',
      '名称': 'Epcos',
      slug: 'epcos',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '41db78b7-772e-4324-8263-4897a6ae684f',
      '名称': 'IXYS',
      slug: 'ixys',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '50f1951b-0bcb-4da9-8a32-d9c7ef69c8d0',
      '名称': 'LEM',
      slug: 'lem',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '338ca8ee-36b5-4988-84bb-afd570f9d3f3',
      '名称': 'Littelfuse',
      slug: 'littelfuse',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPd1Kd',
      '名称': 'MediaTek',
      slug: 'mediatek',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '187f202f-9115-433e-acc5-183fcf30b53e',
      '名称': 'PI',
      slug: 'pi',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: 'jVRgCqSLEjfmNxWovPcI1T',
      '名称': 'Qualcomm',
      slug: 'qualcomm',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '90f7a400-1a41-4848-bb47-9452417a239e',
      '名称': 'Sanrex',
      slug: 'sanrex',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '6c5c79e4-ae71-4058-82b7-f084c1d6a38f',
      '名称': 'Semikron',
      slug: 'semikron',
      '是否激活': true,
      '是否推荐': true
    },
    {
      id: '48f35df7-11c9-474b-8ea2-d1427100878f',
      '名称': 'ncc',
      slug: 'ncc',
      '是否激活': true,
      '是否推荐': false
    },
    {
      id: '574c06df-0e06-4e5a-a0bc-38f210614bfa',
      '名称': '英飞凌',
      slug: '英飞凌',
      '是否激活': true,
      '是否推荐': true
    }
  ]
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand or support not found for slug: cree, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand or support not found for slug: cree, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand or support not found for slug: cree, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand or support not found for slug: cree, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand or support not found for slug: cree, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand or support not found for slug: cree, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
✅ [getBrandData] Found brand: Electronicon
🔍 [getBrandData] Searching for brand with slug: Electronicon
✅ [getBrandData] Found brand: Electronicon
[STDERR] Brand or support not found for slug: Electronicon, id: 11111
Brand or support not found for slug: Electronicon, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
✅ [getBrandData] Found brand: Electronicon
🔍 [getBrandData] Searching for brand with slug: Electronicon
✅ [getBrandData] Found brand: Electronicon
[STDERR] Brand or support not found for slug: Electronicon, id: 22222
Brand or support not found for slug: Electronicon, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
✅ [getBrandData] Found brand: Electronicon
🔍 [getBrandData] Searching for brand with slug: Electronicon
✅ [getBrandData] Found brand: Electronicon
[STDERR] Brand or support not found for slug: Electronicon, id: 33333
Brand or support not found for slug: Electronicon, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
✅ [getBrandData] Found brand: Epcos
🔍 [getBrandData] Searching for brand with slug: epcos
✅ [getBrandData] Found brand: Epcos
[STDERR] Brand or support not found for slug: epcos, id: 11111
Brand or support not found for slug: epcos, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
✅ [getBrandData] Found brand: Epcos
🔍 [getBrandData] Searching for brand with slug: epcos
✅ [getBrandData] Found brand: Epcos
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
✅ [getBrandData] Found brand: Epcos
🔍 [getBrandData] Searching for brand with slug: epcos
✅ [getBrandData] Found brand: Epcos
[STDERR] Brand or support not found for slug: epcos, id: 22222
Brand or support not found for slug: epcos, id: 22222
[STDERR] Brand or support not found for slug: epcos, id: 33333
Brand or support not found for slug: epcos, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
🔍 [getBrandData] Searching for brand with slug: ixys
✅ [getBrandData] Found brand: IXYS
✅ [getBrandData] Found brand: IXYS
[STDERR] Brand or support not found for slug: ixys, id: 11111
Brand or support not found for slug: ixys, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
✅ [getBrandData] Found brand: IXYS
🔍 [getBrandData] Searching for brand with slug: ixys
✅ [getBrandData] Found brand: IXYS
[STDERR] Brand or support not found for slug: ixys, id: 22222
Brand or support not found for slug: ixys, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
✅ [getBrandData] Found brand: IXYS
🔍 [getBrandData] Searching for brand with slug: ixys
✅ [getBrandData] Found brand: IXYS
[STDERR] Brand or support not found for slug: ixys, id: 33333
Brand or support not found for slug: ixys, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
✅ [getBrandData] Found brand: LEM
🔍 [getBrandData] Searching for brand with slug: lem
✅ [getBrandData] Found brand: LEM
[STDERR] Brand or support not found for slug: lem, id: 11111
Brand or support not found for slug: lem, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand or support not found for slug: lem, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand or support not found for slug: lem, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand or support not found for slug: lem, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand or support not found for slug: lem, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
[STDOUT] ✅ [getBrandData] Found brand: Littelfuse
[STDERR] Brand or support not found for slug: littelfuse, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
[STDOUT] ✅ [getBrandData] Found brand: Littelfuse
[STDERR] Brand or support not found for slug: littelfuse, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
✅ [getBrandData] Found brand: Littelfuse
🔍 [getBrandData] Searching for brand with slug: littelfuse
✅ [getBrandData] Found brand: Littelfuse
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
✅ [getBrandData] Found brand: Littelfuse
🔍 [getBrandData] Searching for brand with slug: littelfuse
✅ [getBrandData] Found brand: Littelfuse
[STDERR] Brand or support not found for slug: littelfuse, id: 33333
Brand or support not found for slug: littelfuse, id: 33333
[STDERR] Brand or support not found for slug: littelfuse, id: 22222
Brand or support not found for slug: littelfuse, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
✅ [getBrandData] Found brand: MediaTek
🔍 [getBrandData] Searching for brand with slug: mediatek
✅ [getBrandData] Found brand: MediaTek
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
✅ [getBrandData] Found brand: MediaTek
🔍 [getBrandData] Searching for brand with slug: mediatek
✅ [getBrandData] Found brand: MediaTek
[STDERR] Brand or support not found for slug: mediatek, id: 22222
Brand or support not found for slug: mediatek, id: 22222
[STDERR] Brand or support not found for slug: mediatek, id: 11111
Brand or support not found for slug: mediatek, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
✅ [getBrandData] Found brand: MediaTek
🔍 [getBrandData] Searching for brand with slug: mediatek
✅ [getBrandData] Found brand: MediaTek
[STDERR] Brand or support not found for slug: mediatek, id: 33333
Brand or support not found for slug: mediatek, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
✅ [getBrandData] Found brand: PI
🔍 [getBrandData] Searching for brand with slug: pi
✅ [getBrandData] Found brand: PI
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
✅ [getBrandData] Found brand: PI
🔍 [getBrandData] Searching for brand with slug: pi
✅ [getBrandData] Found brand: PI
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
✅ [getBrandData] Found brand: PI
🔍 [getBrandData] Searching for brand with slug: pi
✅ [getBrandData] Found brand: PI
[STDERR] Brand or support not found for slug: pi, id: 22222
Brand or support not found for slug: pi, id: 22222
[STDERR] Brand or support not found for slug: pi, id: 33333
Brand or support not found for slug: pi, id: 33333
[STDERR] Brand or support not found for slug: pi, id: 11111
Brand or support not found for slug: pi, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
✅ [getBrandData] Found brand: Qualcomm
🔍 [getBrandData] Searching for brand with slug: qualcomm
✅ [getBrandData] Found brand: Qualcomm
[STDERR] Brand or support not found for slug: qualcomm, id: 11111
Brand or support not found for slug: qualcomm, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
✅ [getBrandData] Found brand: Qualcomm
🔍 [getBrandData] Searching for brand with slug: qualcomm
✅ [getBrandData] Found brand: Qualcomm
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
✅ [getBrandData] Found brand: Qualcomm
🔍 [getBrandData] Searching for brand with slug: qualcomm
✅ [getBrandData] Found brand: Qualcomm
[STDERR] Brand or support not found for slug: qualcomm, id: 22222
Brand or support not found for slug: qualcomm, id: 22222
[STDERR] Brand or support not found for slug: qualcomm, id: 33333
Brand or support not found for slug: qualcomm, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
✅ [getBrandData] Found brand: Sanrex
🔍 [getBrandData] Searching for brand with slug: sanrex
✅ [getBrandData] Found brand: Sanrex
[STDERR] Brand or support not found for slug: sanrex, id: 11111
Brand or support not found for slug: sanrex, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
[STDOUT] ✅ [getBrandData] Found brand: Sanrex
[STDERR] Brand or support not found for slug: sanrex, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
[STDOUT] ✅ [getBrandData] Found brand: Sanrex
[STDERR] Brand or support not found for slug: sanrex, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
[STDOUT] ✅ [getBrandData] Found brand: Sanrex
[STDERR] Brand or support not found for slug: sanrex, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
[STDOUT] ✅ [getBrandData] Found brand: Sanrex
[STDERR] Brand or support not found for slug: sanrex, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDERR] Brand or support not found for slug: semikron, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDERR] Brand or support not found for slug: semikron, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDERR] Brand or support not found for slug: semikron, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDERR] Brand or support not found for slug: semikron, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDERR] Brand or support not found for slug: ncc, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
✅ [getBrandData] Found brand: Semikron
[STDERR] Brand or support not found for slug: semikron, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDERR] Brand or support not found for slug: ncc, id: 11111
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDERR] Brand or support not found for slug: semikron, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDERR] Brand or support not found for slug: ncc, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDERR] Brand or support not found for slug: ncc, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
🔍 [getBrandData] Searching for brand with slug: ncc
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDOUT] ✅ [getBrandData] Found brand: 英飞凌
[STDERR] Brand or support not found for slug: ncc, id: 33333
[STDERR] Brand or support not found for slug: 英飞凌, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
[STDOUT] ✅ [getBrandData] Found brand: 英飞凌
[STDERR] Brand or support not found for slug: 英飞凌, id: 11111
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDERR] Brand or support not found for slug: ncc, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand or support not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C, id: 11111
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand or support not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDERR] Brand or support not found for slug: 英飞凌, id: 22222
Brand or support not found for slug: 英飞凌, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
✅ [getBrandData] Found brand: 英飞凌
🔍 [getBrandData] Searching for brand with slug: 英飞凌
✅ [getBrandData] Found brand: 英飞凌
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand or support not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C, id: 22222
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand or support not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
✅ [getBrandData] Found brand: 英飞凌
🔍 [getBrandData] Searching for brand with slug: 英飞凌
✅ [getBrandData] Found brand: 英飞凌
[STDERR] Brand or support not found for slug: 英飞凌, id: 33333
Brand or support not found for slug: 英飞凌, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
✅ [getBrandData] Found brand: CREE
🔍 [getBrandData] Searching for brand with slug: cree
✅ [getBrandData] Found brand: CREE
[STDERR] Brand or support not found for slug: cree, id: 11111
Brand or support not found for slug: cree, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] Searching for brand with slug: cree
✅ [getBrandData] Found brand: CREE
🔍 [getBrandData] Searching for brand with slug: cree
✅ [getBrandData] Found brand: CREE
[STDERR] Brand or support not found for slug: cree, id: 22222
Brand or support not found for slug: cree, id: 22222
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand or support not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C, id: 33333
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand or support not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
✅ [getBrandData] Found brand: CREE
🔍 [getBrandData] Searching for brand with slug: cree
✅ [getBrandData] Found brand: CREE
[STDERR] Brand or support not found for slug: cree, id: 33333
Brand or support not found for slug: cree, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
✅ [getBrandData] Found brand: Electronicon
🔍 [getBrandData] Searching for brand with slug: Electronicon
✅ [getBrandData] Found brand: Electronicon
[STDERR] Brand or support not found for slug: Electronicon, id: 11111
Brand or support not found for slug: Electronicon, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
✅ [getBrandData] Found brand: Electronicon
🔍 [getBrandData] Searching for brand with slug: Electronicon
✅ [getBrandData] Found brand: Electronicon
[STDERR] Brand or support not found for slug: Electronicon, id: 22222
Brand or support not found for slug: Electronicon, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
✅ [getBrandData] Found brand: Electronicon
🔍 [getBrandData] Searching for brand with slug: Electronicon
✅ [getBrandData] Found brand: Electronicon
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
✅ [getBrandData] Found brand: Epcos
🔍 [getBrandData] Searching for brand with slug: epcos
✅ [getBrandData] Found brand: Epcos
[STDERR] Brand or support not found for slug: Electronicon, id: 33333
Brand or support not found for slug: Electronicon, id: 33333
Brand or support not found for slug: epcos, id: 11111
Brand or support not found for slug: epcos, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
[STDOUT] ✅ [getBrandData] Found brand: Epcos
[STDERR] Brand or support not found for slug: epcos, id: 22222
[STDOUT] ✅ [getBrandData] Found brand: Epcos
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
[STDERR] Brand or support not found for slug: epcos, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
[STDOUT] ✅ [getBrandData] Found brand: Epcos
[STDERR] Brand or support not found for slug: epcos, id: 22222
[STDOUT] ✅ [getBrandData] Found brand: Epcos
[STDERR] Brand or support not found for slug: epcos, id: 33333
[STDOUT]    Generating static pages (179/359) 
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
[STDOUT] ✅ [getBrandData] Found brand: IXYS
[STDERR] Brand or support not found for slug: ixys, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
[STDOUT] ✅ [getBrandData] Found brand: IXYS
[STDERR] Brand or support not found for slug: ixys, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
✅ [getBrandData] Found brand: IXYS
🔍 [getBrandData] Searching for brand with slug: ixys
✅ [getBrandData] Found brand: IXYS
[STDERR] Brand or support not found for slug: ixys, id: 22222
Brand or support not found for slug: ixys, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
✅ [getBrandData] Found brand: LEM
🔍 [getBrandData] Searching for brand with slug: lem
✅ [getBrandData] Found brand: LEM
[STDERR] Brand or support not found for slug: lem, id: 11111
Brand or support not found for slug: lem, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
✅ [getBrandData] Found brand: IXYS
🔍 [getBrandData] Searching for brand with slug: ixys
✅ [getBrandData] Found brand: IXYS
[STDERR] Brand or support not found for slug: ixys, id: 33333
Brand or support not found for slug: ixys, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
✅ [getBrandData] Found brand: LEM
🔍 [getBrandData] Searching for brand with slug: lem
✅ [getBrandData] Found brand: LEM
[STDERR] Brand or support not found for slug: lem, id: 22222
Brand or support not found for slug: lem, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
✅ [getBrandData] Found brand: LEM
🔍 [getBrandData] Searching for brand with slug: lem
✅ [getBrandData] Found brand: LEM
[STDERR] Brand or support not found for slug: lem, id: 33333
Brand or support not found for slug: lem, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
✅ [getBrandData] Found brand: Littelfuse
🔍 [getBrandData] Searching for brand with slug: littelfuse
✅ [getBrandData] Found brand: Littelfuse
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
✅ [getBrandData] Found brand: Littelfuse
🔍 [getBrandData] Searching for brand with slug: littelfuse
✅ [getBrandData] Found brand: Littelfuse
[STDERR] Brand or support not found for slug: littelfuse, id: 22222
Brand or support not found for slug: littelfuse, id: 22222
Brand or support not found for slug: littelfuse, id: 11111
Brand or support not found for slug: littelfuse, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
✅ [getBrandData] Found brand: Littelfuse
🔍 [getBrandData] Searching for brand with slug: littelfuse
✅ [getBrandData] Found brand: Littelfuse
[STDERR] Brand or support not found for slug: littelfuse, id: 33333
Brand or support not found for slug: littelfuse, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
✅ [getBrandData] Found brand: MediaTek
🔍 [getBrandData] Searching for brand with slug: mediatek
✅ [getBrandData] Found brand: MediaTek
[STDERR] Brand or support not found for slug: mediatek, id: 11111
Brand or support not found for slug: mediatek, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
✅ [getBrandData] Found brand: MediaTek
🔍 [getBrandData] Searching for brand with slug: mediatek
✅ [getBrandData] Found brand: MediaTek
[STDERR] Brand or support not found for slug: mediatek, id: 22222
Brand or support not found for slug: mediatek, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
✅ [getBrandData] Found brand: PI
🔍 [getBrandData] Searching for brand with slug: pi
✅ [getBrandData] Found brand: PI
[STDERR] Brand or support not found for slug: pi, id: 22222
Brand or support not found for slug: pi, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
✅ [getBrandData] Found brand: PI
🔍 [getBrandData] Searching for brand with slug: pi
✅ [getBrandData] Found brand: PI
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
✅ [getBrandData] Found brand: MediaTek
🔍 [getBrandData] Searching for brand with slug: mediatek
✅ [getBrandData] Found brand: MediaTek
[STDERR] Brand or support not found for slug: mediatek, id: 33333
Brand or support not found for slug: mediatek, id: 33333
[STDERR] Brand or support not found for slug: pi, id: 11111
Brand or support not found for slug: pi, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
✅ [getBrandData] Found brand: PI
🔍 [getBrandData] Searching for brand with slug: pi
✅ [getBrandData] Found brand: PI
[STDERR] Brand or support not found for slug: pi, id: 33333
Brand or support not found for slug: pi, id: 33333
Brand or support not found for slug: qualcomm, id: 11111
Brand or support not found for slug: qualcomm, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
✅ [getBrandData] Found brand: Qualcomm
🔍 [getBrandData] Searching for brand with slug: qualcomm
✅ [getBrandData] Found brand: Qualcomm
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
✅ [getBrandData] Found brand: Qualcomm
🔍 [getBrandData] Searching for brand with slug: qualcomm
✅ [getBrandData] Found brand: Qualcomm
[STDERR] Brand or support not found for slug: qualcomm, id: 22222
Brand or support not found for slug: qualcomm, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
[STDOUT] ✅ [getBrandData] Found brand: Qualcomm
[STDERR] Brand or support not found for slug: qualcomm, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
[STDOUT] ✅ [getBrandData] Found brand: Qualcomm
[STDERR] Brand or support not found for slug: qualcomm, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
🔍 [getBrandData] Searching for brand with slug: sanrex
[STDOUT] ✅ [getBrandData] Found brand: Sanrex
[STDERR] Brand or support not found for slug: sanrex, id: 11111
[STDOUT] ✅ [getBrandData] Found brand: Sanrex
✅ [getBrandData] Found brand: Sanrex
[STDERR] Brand or support not found for slug: sanrex, id: 33333
Brand or support not found for slug: sanrex, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
✅ [getBrandData] Found brand: Sanrex
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
✅ [getBrandData] Found brand: Sanrex
[STDOUT] ✅ [getBrandData] Found brand: Sanrex
[STDERR] Brand or support not found for slug: sanrex, id: 11111
Brand or support not found for slug: sanrex, id: 33333
[STDERR] Brand or support not found for slug: sanrex, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDERR] Brand or support not found for slug: semikron, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDERR] Brand or support not found for slug: semikron, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDERR] Brand or support not found for slug: semikron, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDERR] Brand or support not found for slug: semikron, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDERR] Brand or support not found for slug: semikron, id: 33333
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDERR] Brand or support not found for slug: semikron, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDERR] Brand or support not found for slug: ncc, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDERR] Brand or support not found for slug: ncc, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDERR] Brand or support not found for slug: ncc, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDERR] Brand or support not found for slug: ncc, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDERR] Brand or support not found for slug: ncc, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDERR] Brand or support not found for slug: ncc, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
✅ [getBrandData] Found brand: 英飞凌
🔍 [getBrandData] Searching for brand with slug: 英飞凌
✅ [getBrandData] Found brand: 英飞凌
[STDERR] Brand or support not found for slug: 英飞凌, id: 11111
Brand or support not found for slug: 英飞凌, id: 11111
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand or support not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C, id: 11111
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand or support not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C, id: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
✅ [getBrandData] Found brand: 英飞凌
🔍 [getBrandData] Searching for brand with slug: 英飞凌
✅ [getBrandData] Found brand: 英飞凌
[STDERR] Brand or support not found for slug: 英飞凌, id: 22222
Brand or support not found for slug: 英飞凌, id: 22222
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand or support not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C, id: 22222
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand or support not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C, id: 22222
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] Searching for brand with slug: 英飞凌
✅ [getBrandData] Found brand: 英飞凌
🔍 [getBrandData] Searching for brand with slug: 英飞凌
✅ [getBrandData] Found brand: 英飞凌
[STDERR] Brand or support not found for slug: 英飞凌, id: 33333
Brand or support not found for slug: 英飞凌, id: 33333
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand or support not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C, id: 33333
❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
Brand or support not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C, id: 33333
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**"))] | order(_createdAt desc) [0...12] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**"))])
    }
  
Query parameters: {
  limit: 12,
  offset: 0,
  category: undefined,
  brand: undefined,
  featured: undefined
}
Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**"))] | order(_createdAt desc) [0...12] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**"))])
    }
  
Query parameters: {
  limit: 12,
  offset: 0,
  category: undefined,
  brand: undefined,
  featured: undefined
}
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**"))] | order(_createdAt desc) [0...12] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**"))])
    }
  
[STDOUT] Query parameters: {
  limit: 12,
  offset: 0,
  category: undefined,
  brand: undefined,
  featured: undefined
}
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**"))] | order(_createdAt desc) [0...12] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**"))])
    }
  
[STDOUT] Query parameters: {
  limit: 12,
  offset: 0,
  category: undefined,
  brand: undefined,
  featured: undefined
}
[STDOUT] Products fetch result: {
  totalProducts: 14,
  fetchedProducts: 12,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
[STDOUT] Products fetch result: {
  totalProducts: 14,
  fetchedProducts: 12,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
[STDOUT] Products fetch result: {
  totalProducts: 14,
  fetchedProducts: 12,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
[STDOUT] Products fetch result: {
  totalProducts: 14,
  fetchedProducts: 12,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
[STDERR] Solution not found for slug: swift%20power%20supply
[STDERR] Solution not found for slug: swift%20power%20supply
[STDERR] Solution not found for slug: sic%20mosfet
[STDERR] Solution not found for slug: sic%20mosfet
[STDERR] Solution not found for slug: swift%20power%20supply
[STDERR] Solution not found for slug: swift%20power%20supply
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
[STDOUT] Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
[STDOUT] Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
[STDERR] Solution not found for slug: sic%20mosfet
[STDERR] Solution not found for slug: sic%20mosfet
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Electronicon
[STDOUT] Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Electronicon
[STDOUT] Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Epcos
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Epcos
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: IXYS
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDOUT] Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDOUT] Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: IXYS
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Littelfuse
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Littelfuse
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: MediaTek
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
[STDOUT] ✅ [getBrandData] Found brand: MediaTek
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: PI
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: PI
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Qualcomm
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Qualcomm
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Sanrex
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDOUT] Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDOUT] Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] ✅ [getBrandData] Found brand: Sanrex
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: 英飞凌
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] ✅ [getBrandData] Found brand: 英飞凌
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDERR] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDERR] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
[STDOUT] Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "cree"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'cree',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("cree" in relatedBrands[]->slug.current || primaryBrand->slug.current == "cree")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'cree',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] Products fetch result: {
  totalProducts: 4,
  fetchedProducts: 4,
  firstProduct: {
    _createdAt: '2025-09-14T13:03:01Z',
    _id: 'eac33791-573d-4a1a-aae2-73b4cd447abc',
    _type: 'product',
    _updatedAt: '2025-09-14T13:04:16Z',
    brand: { logo: null, name: 'CREE', slug: 'cree' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-14T13:02:58.264Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '11111',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '11111',
    slug: 'sic mosfet',
    title: '111111'
  }
}
[STDOUT] Solutions fetch result: {
  totalSolutions: 6,
  fetchedSolutions: 4,
  firstSolution: {
    _createdAt: '2025-09-14T13:00:42Z',
    _id: 'ee14d323-2790-4cc5-985f-860cb36f2704',
    _updatedAt: '2025-09-14T13:01:23Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: 'a1d8e9bb-bad5-40f0-8596-af924e655f9d',
      logo: null,
      name: 'CREE',
      slug: 'cree'
    },
    publishedAt: '2025-09-14T13:00:40.311Z',
    relatedBrands: null,
    slug: '11111',
    summary: '11111',
    targetMarket: 'industrial-automation',
    title: '11111',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Epcos
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] ✅ [getBrandData] Found brand: Electronicon
[STDOUT] Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: epcos
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "epcos"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'epcos',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("epcos" in relatedBrands[]->slug.current || primaryBrand->slug.current == "epcos")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'epcos',
  featured: undefined
}
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "Electronicon"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'Electronicon',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("Electronicon" in relatedBrands[]->slug.current || primaryBrand->slug.current == "Electronicon")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'Electronicon',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Epcos
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] ✅ [getBrandData] Found brand: Electronicon
[STDOUT] Products fetch result: {
  totalProducts: 2,
  fetchedProducts: 2,
  firstProduct: {
    _createdAt: '2025-09-16T22:13:44Z',
    _id: '163d8624-deb8-42a1-944a-af946f4247bc',
    _type: 'product',
    _updatedAt: '2025-09-16T22:14:21Z',
    brand: { logo: null, name: 'Electronicon', slug: 'Electronicon' },
    category: { name: '电容', slug: 'capacitor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-16T22:13:40.823Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: '99999',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: null,
    slug: '99999',
    title: '99999'
  }
}
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDOUT] Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "lem"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'lem',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("lem" in relatedBrands[]->slug.current || primaryBrand->slug.current == "lem")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'lem',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
Products fetch result: {
  totalProducts: 3,
  fetchedProducts: 3,
  firstProduct: {
    _createdAt: '2025-09-10T11:02:28Z',
    _id: '46fd4bea-4492-45f2-a216-8af2a89f8aa2',
    _type: 'product',
    _updatedAt: '2025-09-10T11:03:44Z',
    brand: { logo: null, name: 'LEM', slug: 'lem' },
    category: { name: '传感器', slug: 'sensor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-10T11:02:15.065Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'la55-p',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: '电流传感器la55-p',
    slug: 'la55-p',
    title: '电流传感器la55-p'
  }
}
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: IXYS
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ixys"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ixys',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ixys" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ixys")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ixys',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: IXYS
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: {
  totalSolutions: 1,
  fetchedSolutions: 1,
  firstSolution: {
    _createdAt: '2025-09-15T10:06:14Z',
    _id: 'e4682cee-1cd1-4018-97ce-0650c7f700c9',
    _updatedAt: '2025-09-15T10:07:20Z',
    complexity: 'medium',
    coverImage: null,
    description: [ [Object] ],
    isFeatured: false,
    isPublished: true,
    primaryBrand: {
      _id: '41db78b7-772e-4324-8263-4897a6ae684f',
      logo: null,
      name: 'IXYS',
      slug: 'ixys'
    },
    publishedAt: '2025-09-15T10:05:59.500Z',
    relatedBrands: null,
    slug: '99999',
    summary: '99999',
    targetMarket: 'industrial-automation',
    title: '99999',
    viewCount: 0
  }
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: MediaTek
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: mediatek
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "mediatek"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'mediatek',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("mediatek" in relatedBrands[]->slug.current || primaryBrand->slug.current == "mediatek")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'mediatek',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: MediaTek
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: PI
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: pi
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "pi"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'pi',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("pi" in relatedBrands[]->slug.current || primaryBrand->slug.current == "pi")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'pi',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: PI
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] ✅ [getBrandData] Found brand: Littelfuse
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: littelfuse
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "littelfuse"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'littelfuse',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("littelfuse" in relatedBrands[]->slug.current || primaryBrand->slug.current == "littelfuse")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'littelfuse',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Littelfuse
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Sanrex
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: sanrex
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "sanrex"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'sanrex',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("sanrex" in relatedBrands[]->slug.current || primaryBrand->slug.current == "sanrex")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'sanrex',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Sanrex
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] ✅ [getBrandData] Found brand: Qualcomm
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: qualcomm
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "qualcomm"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'qualcomm',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("qualcomm" in relatedBrands[]->slug.current || primaryBrand->slug.current == "qualcomm")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'qualcomm',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: Qualcomm
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDOUT] Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "semikron"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'semikron',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("semikron" in relatedBrands[]->slug.current || primaryBrand->slug.current == "semikron")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'semikron',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDOUT] Products fetch result: {
  totalProducts: 1,
  fetchedProducts: 1,
  firstProduct: {
    _createdAt: '2025-09-09T12:09:45Z',
    _id: '86f432e0-c8f3-4b01-8755-257a8db0dff1',
    _type: 'product',
    _updatedAt: '2025-09-09T18:25:17Z',
    brand: { logo: null, name: 'Semikron', slug: 'semikron' },
    category: { name: '功率半导体', slug: 'Power Semiconductor' },
    image: null,
    inventory: {
      inStock: true,
      lastUpdated: '2025-09-09T12:08:57.552Z',
      quantity: 0,
      status: 'in_stock',
      warehouse: null
    },
    isActive: true,
    isFeatured: false,
    isNew: false,
    partNumber: 'SKKT106/16E',
    pricing: {
      currency: 'CNY',
      leadTime: null,
      moq: null,
      price: null,
      tiers: null
    },
    shortDescription: 'SKKT106/16E',
    slug: 'SKKT106/16E',
    title: 'SKKT106/16E'
  }
}
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ncc
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "ncc"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: 'ncc',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("ncc" in relatedBrands[]->slug.current || primaryBrand->slug.current == "ncc")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: 'ncc',
  featured: undefined
}
[STDOUT] ✅ [getBrandData] Found brand: 英飞凌
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: 英飞凌
[STDOUT] ✅ [getBrandData] Found brand: ncc
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "英飞凌"])
    }
  
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDERR] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] Fetching products with query: 
    {
      "products": *[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"] | order(_createdAt desc) [0...8] {
        
    _id,
    _type,
    partNumber,
    "slug": slug.current,
    title,
    shortDescription,
    image,
    brand->{
      name,
      "slug": slug.current,
      logo
    },
    category->{
      name,
      "slug": slug.current
    },
    pricing{
      currency,
      tiers[]{
        quantity,
        price,
        unit
      },
      moq,
      leadTime,
      // 兼容字段：提取第一个价格作为默认价格
      "price": tiers[0].price,
      "currency": coalesce(currency, "CNY")
    },
    inventory{
      quantity,
      status,
      warehouse,
      lastUpdated,
      // 兼容字段：转换状态为布尔值
      "inStock": status == "in_stock",
      "quantity": coalesce(quantity, 0)
    },
    isActive,
    isFeatured,
    isNew,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "product" && isActive == true && !(_id in path("drafts.**")) && brand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C"])
    }
  
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
[STDOUT] Query parameters: {
  limit: 8,
  offset: 0,
  category: undefined,
  brand: '英飞凌',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("%E8%8B%B1%E9%A3%9E%E5%87%8C" in relatedBrands[]->slug.current || primaryBrand->slug.current == "%E8%8B%B1%E9%A3%9E%E5%87%8C")])
    }
  
Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '%E8%8B%B1%E9%A3%9E%E5%87%8C',
  featured: undefined
}
[STDOUT] Fetching solutions with query: 
    {
      "solutions": *[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")] | order(publishedAt desc) [0...4] {
        
    _id,
    title,
    "slug": slug.current,
    summary,
    description,
    coverImage,
    primaryBrand->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    relatedBrands[]->{
      _id,
      name,
      "slug": slug.current,
      logo
    },
    targetMarket,
    complexity,
    publishedAt,
    isPublished,
    isFeatured,
    viewCount,
    _createdAt,
    _updatedAt
  
      },
      "total": count(*[_type == "solution" && (isPublished == true || !defined(isPublished)) && ("英飞凌" in relatedBrands[]->slug.current || primaryBrand->slug.current == "英飞凌")])
    }
  
[STDOUT] Query parameters: {
  limit: 4,
  offset: 0,
  targetMarket: undefined,
  brand: '英飞凌',
  featured: undefined
}
[STDOUT] 🔍 [getBrandData] No exact match found, trying relaxed search for: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDERR] ❌ [getBrandData] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDERR] Brand not found for slug: %E8%8B%B1%E9%A3%9E%E5%87%8C
[STDOUT] ✅ [getBrandData] Found brand: 英飞凌
[STDOUT] Products fetch result: { totalProducts: 0, fetchedProducts: 0, firstProduct: null }
[STDOUT]    Generating static pages (269/359) 
[STDOUT] Solutions fetch result: { totalSolutions: 0, fetchedSolutions: 0, firstSolution: null }
[STDOUT] 🔧 [BrandProductPage] Loading page for Electronicon/33333 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
[STDOUT] ✅ [getBrandData] Found brand: Electronicon
[STDERR] Brand not found for slug: Electronicon
[STDOUT] 🔍 [getBrandProduct] Searching for product 33333 in brand Electronicon
[STDOUT] 🔧 [BrandProductPage] Loading page for Electronicon/33333 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
[STDOUT] ✅ [getBrandData] Found brand: Electronicon
[STDERR] Brand not found for slug: Electronicon
[STDOUT] 🔍 [getBrandProduct] Searching for product 33333 in brand Electronicon
[STDOUT] 🔧 [BrandProductPage] Loading page for Electronicon/99999 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
[STDOUT] ✅ [getBrandData] Found brand: Electronicon
[STDERR] Brand not found for slug: Electronicon
[STDOUT] 🔍 [getBrandProduct] Searching for product 99999 in brand Electronicon
[STDOUT] 🔧 [BrandProductPage] Loading page for Electronicon/99999 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
[STDOUT] ✅ [getBrandData] Found brand: Electronicon
[STDERR] Brand not found for slug: Electronicon
[STDOUT] 🔍 [getBrandProduct] Searching for product 99999 in brand Electronicon
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/sic%20mosfet (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand not found for slug: cree
[STDOUT] 🔍 [getBrandProduct] Searching for product sic%20mosfet in brand cree
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/sic%20mosfet (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand not found for slug: cree
[STDOUT] 🔍 [getBrandProduct] Searching for product sic%20mosfet in brand cree
[STDOUT] ❌ [getBrandProduct] Product sic%20mosfet not found for brand cree
[STDERR] Product sic%20mosfet not found for brand cree or not associated with this brand
[STDOUT] ❌ [getBrandProduct] Product sic%20mosfet not found for brand cree
[STDERR] Product sic%20mosfet not found for brand cree or not associated with this brand
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] 
Error occurred prerendering page "/zh-CN/brands/cree/products/sic mosfet". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/55555 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand not found for slug: cree
[STDOUT] 🔍 [getBrandProduct] Searching for product 55555 in brand cree
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/55555 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand not found for slug: cree
[STDOUT] 🔍 [getBrandProduct] Searching for product 55555 in brand cree
[STDOUT] ✅ [getBrandProduct] Found product: 99999 for brand Electronicon
[STDOUT] ✅ [getBrandProduct] Found product: 99999 for brand Electronicon
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] 
Error occurred prerendering page "/zh-CN/brands/Electronicon/products/99999". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/11111 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand not found for slug: cree
[STDOUT] 🔍 [getBrandProduct] Searching for product 11111 in brand cree
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/11111 (BUILD TIME)
🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand not found for slug: cree
[STDOUT] 🔍 [getBrandProduct] Searching for product 11111 in brand cree
[STDOUT] ✅ [getBrandProduct] Found product: 55555 for brand cree
[STDOUT] ✅ [getBrandProduct] Found product: 55555 for brand cree
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] 
Error occurred prerendering page "/zh-CN/brands/cree/products/55555". Read more: https://nextjs.org/docs/messages/prerender-error

TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/c4d02120a (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand not found for slug: cree
[STDOUT] 🔍 [getBrandProduct] Searching for product c4d02120a in brand cree
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/c4d02120a (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand not found for slug: cree
[STDOUT] 🔍 [getBrandProduct] Searching for product c4d02120a in brand cree
[STDOUT] ✅ [getBrandProduct] Found product: sic mosfet c4d02120a for brand cree
[STDOUT] ✅ [getBrandProduct] Found product: sic mosfet c4d02120a for brand cree
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] 
Error occurred prerendering page "/zh-CN/brands/cree/products/c4d02120a". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDOUT] 🔧 [BrandProductPage] Loading page for lem/la55-p (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand not found for slug: lem
[STDOUT] 🔍 [getBrandProduct] Searching for product la55-p in brand lem
[STDOUT] 🔧 [BrandProductPage] Loading page for lem/la55-p (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand not found for slug: lem
[STDOUT] 🔍 [getBrandProduct] Searching for product la55-p in brand lem
[STDOUT] ✅ [getBrandProduct] Found product: 11111 for brand cree
[STDOUT] ✅ [getBrandProduct] Found product: 11111 for brand cree
[STDOUT] ✅ [getBrandProduct] Found product: 33333 for brand Electronicon
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDOUT] ✅ [getBrandProduct] Found product: 33333 for brand Electronicon
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] 
Error occurred prerendering page "/zh-CN/brands/Electronicon/products/33333". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDERR] 
Error occurred prerendering page "/zh-CN/brands/cree/products/11111". Read more: https://nextjs.org/docs/messages/prerender-error

TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDOUT] 🔧 [BrandProductPage] Loading page for lem/la35-p (BUILD TIME)
🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand not found for slug: lem
[STDOUT] 🔍 [getBrandProduct] Searching for product la35-p in brand lem
[STDOUT] 🔧 [BrandProductPage] Loading page for lem/la25-p (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] 🔧 [BrandProductPage] Loading page for lem/la35-p (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand not found for slug: lem
[STDOUT] 🔍 [getBrandProduct] Searching for product la25-p in brand lem
[STDOUT] 🔧 [BrandProductPage] Loading page for lem/la25-p (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand not found for slug: lem
[STDOUT] 🔍 [getBrandProduct] Searching for product la35-p in brand lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand not found for slug: lem
[STDOUT] 🔍 [getBrandProduct] Searching for product la25-p in brand lem
[STDOUT] ✅ [getBrandProduct] Found product: 电流传感器la55-p for brand lem
[STDOUT] ✅ [getBrandProduct] Found product: 电流传感器la55-p for brand lem
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] 
Error occurred prerendering page "/zh-CN/brands/lem/products/la55-p". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDOUT] ✅ [getBrandProduct] Found product: 电流传感器la25-p for brand lem
[STDOUT] ✅ [getBrandProduct] Found product: 电流传感器la25-p for brand lem
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDOUT] 🔧 [BrandProductPage] Loading page for semikron/SKKT106%2F16E (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDERR] Brand not found for slug: semikron
[STDOUT] 🔍 [getBrandProduct] Searching for product SKKT106%2F16E in brand semikron
[STDOUT] 🔧 [BrandProductPage] Loading page for semikron/SKKT106%2F16E (BUILD TIME)
🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDERR] Brand not found for slug: semikron
[STDOUT] 🔍 [getBrandProduct] Searching for product SKKT106%2F16E in brand semikron
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] 
Error occurred prerendering page "/zh-CN/brands/lem/products/la25-p". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDOUT] 🔧 [BrandProductPage] Loading page for stmicroelectronics/stm32f407vgt6 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: stmicroelectronics
[STDOUT] 🔧 [BrandProductPage] Loading page for stmicroelectronics/stm32f407vgt6 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: stmicroelectronics
[STDOUT] ❌ [getBrandProduct] Product SKKT106%2F16E not found for brand semikron
[STDERR] Product SKKT106%2F16E not found for brand semikron or not associated with this brand
[STDOUT] ❌ [getBrandProduct] Product SKKT106%2F16E not found for brand semikron
[STDERR] Product SKKT106%2F16E not found for brand semikron or not associated with this brand
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] 
Error occurred prerendering page "/zh-CN/brands/semikron/products/SKKT106%2F16E". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDOUT] 🔧 [BrandProductPage] Loading page for ti/opa2134pa (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ti
[STDOUT] 🔍 [getBrandData] No exact match found, trying relaxed search for: ti
[STDERR] ❌ [getBrandData] Brand not found for slug: ti
[STDOUT] 🔍 [getBrandProduct] Searching for product opa2134pa in brand ti
[STDERR] Brand not found for slug: ti
[STDOUT] 🔧 [BrandProductPage] Loading page for ti/opa2134pa (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ti
[STDOUT] 🔍 [getBrandData] No exact match found, trying relaxed search for: ti
[STDERR] ❌ [getBrandData] Brand not found for slug: ti
[STDERR] Brand not found for slug: ti
[STDOUT] 🔍 [getBrandProduct] Searching for product opa2134pa in brand ti
[STDOUT] 🔍 [getBrandData] No exact match found, trying relaxed search for: stmicroelectronics
[STDOUT] 🔍 [getBrandData] No exact match found, trying relaxed search for: stmicroelectronics
[STDOUT] ✅ [getBrandProduct] Found product: 电流传感器la35-p for brand lem
[STDOUT] ✅ [getBrandProduct] Found product: 电流传感器la35-p for brand lem
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] 
Error occurred prerendering page "/zh-CN/brands/lem/products/la35-p". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDOUT] 🔧 [BrandProductPage] Loading page for Electronicon/99999 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: Electronicon
[STDOUT] ✅ [getBrandData] Found brand: Electronicon
[STDERR] Brand not found for slug: Electronicon
[STDOUT] 🔍 [getBrandProduct] Searching for product 99999 in brand Electronicon
[STDOUT] ✅ [getBrandProduct] Found product: null for brand ti
[STDOUT] ✅ [getBrandProduct] Found product: null for brand ti
[STDOUT] 🔧 [BrandProductPage] Loading page for Electronicon/99999 (BUILD TIME)
🔍 [getBrandData] Searching for brand with slug: Electronicon
[STDERR] TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974) {
  digest: '2043954771'
}
[STDOUT] ✅ [getBrandData] Found brand: Electronicon
[STDERR] Brand not found for slug: Electronicon
[STDOUT] 🔍 [getBrandProduct] Searching for product 99999 in brand Electronicon
[STDERR] TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974) {
  digest: '2043954771'
}
[STDOUT] ✅ [getBrandProduct] Found product: 99999 for brand Electronicon
[STDOUT] ✅ [getBrandProduct] Found product: 99999 for brand Electronicon
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974) {
  digest: '2043954771'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] 
Error occurred prerendering page "/zh-CN/brands/ti/products/opa2134pa". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] 
Error occurred prerendering page "/en/brands/Electronicon/products/99999". Read more: https://nextjs.org/docs/messages/prerender-error

TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974)
[STDOUT] 🔧 [BrandProductPage] Loading page for Electronicon/33333 (BUILD TIME)
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/sic%20mosfet (BUILD TIME)
🔍 [getBrandData] Searching for brand with slug: cree
🔍 [getBrandData] Searching for brand with slug: Electronicon
[STDOUT] ✅ [getBrandData] Found brand: Electronicon
[STDERR] Brand not found for slug: Electronicon
Brand not found for slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
🔍 [getBrandProduct] Searching for product 33333 in brand Electronicon
🔍 [getBrandProduct] Searching for product sic%20mosfet in brand cree
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/sic%20mosfet (BUILD TIME)
[STDOUT] 🔧 [BrandProductPage] Loading page for Electronicon/33333 (BUILD TIME)
🔍 [getBrandData] Searching for brand with slug: Electronicon
🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: Electronicon
[STDERR] Brand not found for slug: Electronicon
Brand not found for slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
🔍 [getBrandProduct] Searching for product 33333 in brand Electronicon
🔍 [getBrandProduct] Searching for product sic%20mosfet in brand cree
[STDOUT] ✅ [getBrandProduct] Found product: 33333 for brand Electronicon
[STDOUT] ✅ [getBrandProduct] Found product: 33333 for brand Electronicon
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDOUT] ❌ [getBrandProduct] Product sic%20mosfet not found for brand cree
[STDERR] Product sic%20mosfet not found for brand cree or not associated with this brand
[STDOUT] ❌ [getBrandProduct] Product sic%20mosfet not found for brand cree
[STDERR] Product sic%20mosfet not found for brand cree or not associated with this brand
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] 
Error occurred prerendering page "/en/brands/cree/products/sic mosfet". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/55555 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand not found for slug: cree
[STDOUT] 🔍 [getBrandProduct] Searching for product 55555 in brand cree
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/55555 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand not found for slug: cree
[STDOUT] 🔍 [getBrandProduct] Searching for product 55555 in brand cree
[STDOUT] ✅ [getBrandProduct] Found product: 55555 for brand cree
[STDOUT] ✅ [getBrandProduct] Found product: 55555 for brand cree
[STDERR] 
Error occurred prerendering page "/en/brands/Electronicon/products/33333". Read more: https://nextjs.org/docs/messages/prerender-error

TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/11111 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand not found for slug: cree
[STDOUT] 🔍 [getBrandProduct] Searching for product 11111 in brand cree
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/11111 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand not found for slug: cree
[STDOUT] 🔍 [getBrandProduct] Searching for product 11111 in brand cree
[STDOUT] ✅ [getBrandProduct] Found product: 11111 for brand cree
[STDOUT] ✅ [getBrandProduct] Found product: 11111 for brand cree
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] 
Error occurred prerendering page "/en/brands/cree/products/55555". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/c4d02120a (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand not found for slug: cree
[STDOUT] 🔍 [getBrandProduct] Searching for product c4d02120a in brand cree
[STDOUT] 🔧 [BrandProductPage] Loading page for cree/c4d02120a (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] Brand not found for slug: cree
[STDOUT] 🔍 [getBrandProduct] Searching for product c4d02120a in brand cree
[STDOUT] ✅ [getBrandProduct] Found product: sic mosfet c4d02120a for brand cree
[STDOUT] ✅ [getBrandProduct] Found product: sic mosfet c4d02120a for brand cree
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] 
Error occurred prerendering page "/en/brands/cree/products/11111". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDOUT] 🔧 [BrandProductPage] Loading page for lem/la55-p (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand not found for slug: lem
[STDOUT] 🔍 [getBrandProduct] Searching for product la55-p in brand lem
[STDOUT] ✅ [getBrandProduct] Found product: 电流传感器la55-p for brand lem
[STDOUT] 🔧 [BrandProductPage] Loading page for lem/la55-p (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand not found for slug: lem
[STDOUT] 🔍 [getBrandProduct] Searching for product la55-p in brand lem
[STDOUT] ✅ [getBrandProduct] Found product: 电流传感器la55-p for brand lem
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
  digest: '4082373619'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
  digest: '4082373619'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
  digest: '4082373619'
}
[STDERR] 
Error occurred prerendering page "/en/brands/cree/products/c4d02120a". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDOUT] 🔧 [BrandProductPage] Loading page for lem/la35-p (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand not found for slug: lem
[STDOUT] 🔍 [getBrandProduct] Searching for product la35-p in brand lem
[STDOUT] ✅ [getBrandProduct] Found product: 电流传感器la35-p for brand lem
[STDOUT] 🔧 [BrandProductPage] Loading page for lem/la35-p (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand not found for slug: lem
[STDOUT] 🔍 [getBrandProduct] Searching for product la35-p in brand lem
[STDOUT] ✅ [getBrandProduct] Found product: 电流传感器la35-p for brand lem
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at runNextTicks (node:internal/process/task_queues:69:3)
    at listOnTimeout (node:internal/timers:549:9)
    at process.processTimers (node:internal/timers:523:7) {
  digest: '215584410'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
  digest: '4082373619'
}
[STDERR] ❌ [getBrandData] Brand not found for slug: stmicroelectronics
[STDERR] Brand not found for slug: stmicroelectronics
[STDOUT] 🔍 [getBrandProduct] Searching for product stm32f407vgt6 in brand stmicroelectronics
[STDERR] ❌ [getBrandData] Brand not found for slug: stmicroelectronics
[STDOUT] 🔍 [getBrandProduct] Searching for product stm32f407vgt6 in brand stmicroelectronics
[STDERR] Brand not found for slug: stmicroelectronics
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
  digest: '4082373619'
}
[STDERR] 
Error occurred prerendering page "/en/brands/lem/products/la55-p". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
[STDOUT] 🔧 [BrandProductPage] Loading page for lem/la25-p (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand not found for slug: lem
[STDOUT] 🔍 [getBrandProduct] Searching for product la25-p in brand lem
[STDOUT] 🔧 [BrandProductPage] Loading page for lem/la25-p (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: lem
[STDOUT] ✅ [getBrandData] Found brand: LEM
[STDERR] Brand not found for slug: lem
[STDOUT] 🔍 [getBrandProduct] Searching for product la25-p in brand lem
[STDOUT] ✅ [getBrandProduct] Found product: 电流传感器la25-p for brand lem
[STDOUT] ✅ [getBrandProduct] Found product: 电流传感器la25-p for brand lem
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] 
Error occurred prerendering page "/en/brands/lem/products/la35-p". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at runNextTicks (node:internal/process/task_queues:69:3)
    at listOnTimeout (node:internal/timers:549:9)
    at process.processTimers (node:internal/timers:523:7)
[STDOUT] 🔧 [BrandProductPage] Loading page for semikron/SKKT106%2F16E (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDERR] Brand not found for slug: semikron
[STDOUT] 🔍 [getBrandProduct] Searching for product SKKT106%2F16E in brand semikron
[STDOUT] 🔧 [BrandProductPage] Loading page for semikron/SKKT106%2F16E (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: semikron
[STDOUT] ✅ [getBrandData] Found brand: Semikron
[STDERR] Brand not found for slug: semikron
[STDOUT] 🔍 [getBrandProduct] Searching for product SKKT106%2F16E in brand semikron
[STDOUT] ❌ [getBrandProduct] Product SKKT106%2F16E not found for brand semikron
[STDERR] Product SKKT106%2F16E not found for brand semikron or not associated with this brand
[STDOUT] ❌ [getBrandProduct] Product SKKT106%2F16E not found for brand semikron
[STDERR] Product SKKT106%2F16E not found for brand semikron or not associated with this brand
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDERR] 
Error occurred prerendering page "/en/brands/lem/products/la25-p". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647) {
  digest: '574970237'
}
[STDOUT] 🔧 [BrandProductPage] Loading page for stmicroelectronics/stm32f407vgt6 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: stmicroelectronics
[STDOUT] 🔧 [BrandProductPage] Loading page for stmicroelectronics/stm32f407vgt6 (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: stmicroelectronics
[STDOUT] 🔍 [getBrandData] No exact match found, trying relaxed search for: stmicroelectronics
[STDOUT] 🔍 [getBrandData] No exact match found, trying relaxed search for: stmicroelectronics
[STDERR] ❌ [getBrandData] Brand not found for slug: stmicroelectronics
[STDOUT] 🔍 [getBrandProduct] Searching for product stm32f407vgt6 in brand stmicroelectronics
[STDERR] Brand not found for slug: stmicroelectronics
[STDERR] ❌ [getBrandData] Brand not found for slug: stmicroelectronics
[STDOUT] 🔍 [getBrandProduct] Searching for product stm32f407vgt6 in brand stmicroelectronics
[STDERR] Brand not found for slug: stmicroelectronics
[STDERR] 
Error occurred prerendering page "/en/brands/semikron/products/SKKT106%2F16E". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot read properties of undefined (reading 'slug')
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:7647)
[STDOUT] 🔧 [BrandProductPage] Loading page for ti/opa2134pa (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ti
[STDOUT] 🔧 [BrandProductPage] Loading page for ti/opa2134pa (BUILD TIME)
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ti
[STDOUT] 🔍 [getBrandData] No exact match found, trying relaxed search for: ti
[STDOUT] 🔍 [getBrandData] No exact match found, trying relaxed search for: ti
[STDERR] ❌ [getBrandData] Brand not found for slug: ti
[STDOUT] 🔍 [getBrandProduct] Searching for product opa2134pa in brand ti
[STDERR] Brand not found for slug: ti
[STDERR] ❌ [getBrandData] Brand not found for slug: ti
[STDERR] Brand not found for slug: ti
[STDOUT] 🔍 [getBrandProduct] Searching for product opa2134pa in brand ti
[STDOUT] ✅ [getBrandProduct] Found product: null for brand ti
[STDOUT] ✅ [getBrandProduct] Found product: null for brand ti
[STDERR] TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974) {
  digest: '2043954771'
}
[STDERR] TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974) {
  digest: '2043954771'
}
[STDERR] TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974) {
  digest: '2043954771'
}
[STDERR] 
Error occurred prerendering page "/en/brands/ti/products/opa2134pa". Read more: https://nextjs.org/docs/messages/prerender-error

[STDERR] TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974)
[STDOUT] ✅ [getBrandProduct] Found product: null for brand stmicroelectronics
[STDOUT] ✅ [getBrandProduct] Found product: null for brand stmicroelectronics
[STDERR] TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974) {
  digest: '2043954771'
}
[STDERR] TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974) {
  digest: '2043954771'
}
[STDERR] TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974) {
  digest: '2043954771'
}
[STDERR] 
Error occurred prerendering page "/en/brands/stmicroelectronics/products/stm32f407vgt6". Read more: https://nextjs.org/docs/messages/prerender-error

TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974)
[STDOUT] ✅ [getBrandProduct] Found product: null for brand stmicroelectronics
[STDOUT] ✅ [getBrandProduct] Found product: null for brand stmicroelectronics
[STDERR] TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974) {
  digest: '2043954771'
}
TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974) {
  digest: '2043954771'
}
[STDERR] TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974) {
  digest: '2043954771'
}
[STDERR] 
Error occurred prerendering page "/zh-CN/brands/stmicroelectronics/products/stm32f407vgt6". Read more: https://nextjs.org/docs/messages/prerender-error

TypeError: Cannot destructure property 'brand' of 's' as it is null.
    at v (C:\Users\ymlt\Desktop\litong\.next\server\app\[locale]\brands\[slug]\products\[id]\page.js:1:6974)
[STDERR] Product not found for slug: sic%20mosfet
[STDERR] Product not found for slug: sic%20mosfet
[STDERR] Product not found for slug: SKKT106%2F16E
[STDERR] Product not found for slug: SKKT106%2F16E
[STDERR] Product not found for slug: sic%20mosfet
[STDERR] Product not found for slug: sic%20mosfet
[STDERR] Product not found for slug: SKKT106%2F16E
[STDERR] Product not found for slug: SKKT106%2F16E
[STDERR] ⚠️ [safeImageUrl] Image missing asset reference, using fallback: { _type: 'image', alt: 'STMicroelectronics Logo' }
[STDERR] ⚠️ [safeImageUrl] Image missing asset reference, using fallback: { _type: 'image', alt: 'STMicroelectronics Logo' }
[STDERR] ⚠️ [safeImageUrl] Image missing asset reference, using fallback: { _type: 'image', alt: 'STMicroelectronics Logo' }
[STDERR] ⚠️ [safeImageUrl] Image missing asset reference, using fallback: { _type: 'image', alt: 'STMicroelectronics Logo' }
[STDOUT] 🔍 Fetching data for brand: ixys, solution: 99999
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
[STDOUT] ✅ [getBrandData] Found brand: IXYS
[STDOUT] 🔍 Fetching data for brand: ixys, solution: 99999
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
[STDOUT] ✅ [getBrandData] Found brand: IXYS
[STDOUT] 🔍 Fetching data for brand: cree, solution: concrol
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] 🔍 Fetching data for brand: cree, solution: concrol
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: supplysolution
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: supplysolution
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: charger
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: charger
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: motodiriver
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: motodiriver
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: swift%20power%20supply
🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: swift%20power%20supply
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] ❌ Solution not found: swift%20power%20supply
❌ Solution not found: swift%20power%20supply
[STDOUT] 🔍 Fetching data for brand: cree, solution: 11111
🔍 [getBrandData] Searching for brand with slug: cree
🔍 Fetching data for brand: ixys, solution: 99999
🔍 [getBrandData] Searching for brand with slug: ixys
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] ✅ [getBrandData] Found brand: IXYS
[STDOUT] 🔍 Fetching data for brand: cree, solution: 11111
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] 🔍 Fetching data for brand: ixys, solution: 99999
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: ixys
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] ✅ [getBrandData] Found brand: IXYS
[STDOUT] 🔍 Fetching data for brand: cree, solution: concrol
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: concrol
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: supplysolution
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: supplysolution
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: charger
🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: charger
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: motodiriver
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: motodiriver
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDOUT] 🔍 Fetching data for brand: cree, solution: swift%20power%20supply
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] ❌ Solution not found: swift%20power%20supply
[STDOUT] 🔍 Fetching data for brand: cree, solution: swift%20power%20supply
[STDOUT] 🔍 [getBrandData] Searching for brand with slug: cree
[STDOUT] ✅ [getBrandData] Found brand: CREE
[STDERR] ❌ Solution not found: swift%20power%20supply
[STDERR] Article not found for slug: use%20sic%20mosfet
[STDERR] Article not found for slug: use%20sic%20mosfet
[STDERR] Article not found for slug: use%20sic%20mosfet
[STDERR] Article not found for slug: use%20sic%20mosfet
[STDOUT]  ✓ Generating static pages (359/359)
[STDERR] 
[STDERR] > Export encountered errors on following paths:
	/[locale]/brands/[slug]/products/[id]/page: /en/brands/Electronicon/products/33333
	/[locale]/brands/[slug]/products/[id]/page: /en/brands/Electronicon/products/99999
	/[locale]/brands/[slug]/products/[id]/page: /en/brands/cree/products/11111
	/[locale]/brands/[slug]/products/[id]/page: /en/brands/cree/products/55555
	/[locale]/brands/[slug]/products/[id]/page: /en/brands/cree/products/c4d02120a
	/[locale]/brands/[slug]/products/[id]/page: /en/brands/cree/products/sic mosfet
	/[locale]/brands/[slug]/products/[id]/page: /en/brands/lem/products/la25-p
	/[locale]/brands/[slug]/products/[id]/page: /en/brands/lem/products/la35-p
	/[locale]/brands/[slug]/products/[id]/page: /en/brands/lem/products/la55-p
	/[locale]/brands/[slug]/products/[id]/page: /en/brands/semikron/products/SKKT106%2F16E
	/[locale]/brands/[slug]/products/[id]/page: /en/brands/stmicroelectronics/products/stm32f407vgt6
	/[locale]/brands/[slug]/products/[id]/page: /en/brands/ti/products/opa2134pa
	/[locale]/brands/[slug]/products/[id]/page: /zh-CN/brands/Electronicon/products/33333
	/[locale]/brands/[slug]/products/[id]/page: /zh-CN/brands/Electronicon/products/99999
	/[locale]/brands/[slug]/products/[id]/page: /zh-CN/brands/cree/products/11111
	/[locale]/brands/[slug]/products/[id]/page: /zh-CN/brands/cree/products/55555
	/[locale]/brands/[slug]/products/[id]/page: /zh-CN/brands/cree/products/c4d02120a
	/[locale]/brands/[slug]/products/[id]/page: /zh-CN/brands/cree/products/sic mosfet
	/[locale]/brands/[slug]/products/[id]/page: /zh-CN/brands/lem/products/la25-p
	/[locale]/brands/[slug]/products/[id]/page: /zh-CN/brands/lem/products/la35-p
	/[locale]/brands/[slug]/products/[id]/page: /zh-CN/brands/lem/products/la55-p
	/[locale]/brands/[slug]/products/[id]/page: /zh-CN/brands/semikron/products/SKKT106%2F16E
	/[locale]/brands/[slug]/products/[id]/page: /zh-CN/brands/stmicroelectronics/products/stm32f407vgt6
	/[locale]/brands/[slug]/products/[id]/page: /zh-CN/brands/ti/products/opa2134pa
