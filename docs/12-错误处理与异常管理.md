# 错误处理与异常管理

## 错误分类体系

### 错误类型定义
```typescript
// src/lib/errors/types.ts
export enum ErrorType {
  // 客户端错误 4xx
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',
  AUTHORIZATION_ERROR = 'AUTHORIZATION_ERROR',
  NOT_FOUND_ERROR = 'NOT_FOUND_ERROR',
  RATE_LIMIT_ERROR = 'RATE_LIMIT_ERROR',
  
  // 服务端错误 5xx
  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',
  DATABASE_ERROR = 'DATABASE_ERROR',
  EXTERNAL_API_ERROR = 'EXTERNAL_API_ERROR',
  FILE_SYSTEM_ERROR = 'FILE_SYSTEM_ERROR',
  
  // 业务逻辑错误
  BUSINESS_LOGIC_ERROR = 'BUSINESS_LOGIC_ERROR',
  DATA_INTEGRITY_ERROR = 'DATA_INTEGRITY_ERROR',
  CONFIGURATION_ERROR = 'CONFIGURATION_ERROR',
  
  // 网络和性能错误
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT_ERROR = 'TIMEOUT_ERROR',
  RESOURCE_EXHAUSTED_ERROR = 'RESOURCE_EXHAUSTED_ERROR',
}

export interface ErrorContext {
  userId?: string;
  sessionId?: string;
  requestId?: string;
  userAgent?: string;
  ipAddress?: string;
  timestamp: Date;
  url?: string;
  method?: string;
  headers?: Record<string, string>;
  body?: any;
  stack?: string;
}

export interface AppError {
  type: ErrorType;
  message: string;
  code: string;
  statusCode: number;
  context: ErrorContext;
  cause?: Error;
  retryable: boolean;
  userMessage?: string;
  solutions?: string[];
}
```

### 自定义错误类
```typescript
// src/lib/errors/AppError.ts
export class AppError extends Error {
  public readonly type: ErrorType;
  public readonly code: string;
  public readonly statusCode: number;
  public readonly context: ErrorContext;
  public readonly retryable: boolean;
  public readonly userMessage?: string;
  public readonly solutions?: string[];
  public readonly cause?: Error;

  constructor(
    type: ErrorType,
    message: string,
    options: {
      code?: string;
      statusCode?: number;
      context?: Partial<ErrorContext>;
      retryable?: boolean;
      userMessage?: string;
      solutions?: string[];
      cause?: Error;
    } = {}
  ) {
    super(message);
    
    this.name = 'AppError';
    this.type = type;
    this.code = options.code || type;
    this.statusCode = options.statusCode || this.getDefaultStatusCode(type);
    this.retryable = options.retryable ?? this.getDefaultRetryable(type);
    this.userMessage = options.userMessage;
    this.solutions = options.solutions;
    this.cause = options.cause;
    
    this.context = {
      timestamp: new Date(),
      ...options.context,
    };

    // 确保错误堆栈正确显示
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, AppError);
    }
  }

  private getDefaultStatusCode(type: ErrorType): number {
    const statusCodeMap: Record<ErrorType, number> = {
      [ErrorType.VALIDATION_ERROR]: 400,
      [ErrorType.AUTHENTICATION_ERROR]: 401,
      [ErrorType.AUTHORIZATION_ERROR]: 403,
      [ErrorType.NOT_FOUND_ERROR]: 404,
      [ErrorType.RATE_LIMIT_ERROR]: 429,
      [ErrorType.INTERNAL_SERVER_ERROR]: 500,
      [ErrorType.DATABASE_ERROR]: 500,
      [ErrorType.EXTERNAL_API_ERROR]: 502,
      [ErrorType.FILE_SYSTEM_ERROR]: 500,
      [ErrorType.BUSINESS_LOGIC_ERROR]: 400,
      [ErrorType.DATA_INTEGRITY_ERROR]: 409,
      [ErrorType.CONFIGURATION_ERROR]: 500,
      [ErrorType.NETWORK_ERROR]: 503,
      [ErrorType.TIMEOUT_ERROR]: 504,
      [ErrorType.RESOURCE_EXHAUSTED_ERROR]: 503,
    };
    
    return statusCodeMap[type] || 500;
  }

  private getDefaultRetryable(type: ErrorType): boolean {
    const retryableTypes = [
      ErrorType.NETWORK_ERROR,
      ErrorType.TIMEOUT_ERROR,
      ErrorType.RESOURCE_EXHAUSTED_ERROR,
      ErrorType.EXTERNAL_API_ERROR,
    ];
    
    return retryableTypes.includes(type);
  }

  // 转换为API响应格式
  toJSON() {
    return {
      error: {
        type: this.type,
        code: this.code,
        message: this.userMessage || this.message,
        statusCode: this.statusCode,
        retryable: this.retryable,
        solutions: this.solutions,
        requestId: this.context.requestId,
        timestamp: this.context.timestamp,
      },
    };
  }

  // 转换为日志格式
  toLogFormat() {
    return {
      error: {
        type: this.type,
        code: this.code,
        message: this.message,
        statusCode: this.statusCode,
        stack: this.stack,
        context: this.context,
        cause: this.cause?.message,
      },
    };
  }
}

// 预定义错误工厂函数
export const ErrorFactory = {
  validation: (message: string, field?: string) =>
    new AppError(ErrorType.VALIDATION_ERROR, message, {
      code: 'VALIDATION_FAILED',
      userMessage: `输入验证失败: ${message}`,
      solutions: ['请检查输入格式', '确保所有必填字段已填写', '联系技术支持'],
      context: { field },
    }),

  notFound: (resource: string, id?: string) =>
    new AppError(ErrorType.NOT_FOUND_ERROR, `${resource} not found`, {
      code: 'RESOURCE_NOT_FOUND',
      userMessage: '请求的资源不存在',
      solutions: ['检查URL是否正确', '确认资源是否存在', '返回上一页重试'],
      context: { resource, resourceId: id },
    }),

  rateLimit: (limit: number, windowMs: number) =>
    new AppError(ErrorType.RATE_LIMIT_ERROR, 'Rate limit exceeded', {
      code: 'RATE_LIMIT_EXCEEDED',
      userMessage: '请求过于频繁，请稍后再试',
      retryable: true,
      solutions: [
        `请等待 ${Math.ceil(windowMs / 60000)} 分钟后重试`,
        '减少请求频率',
        '联系技术支持提升限制',
      ],
      context: { limit, windowMs },
    }),

  database: (operation: string, cause?: Error) =>
    new AppError(ErrorType.DATABASE_ERROR, `Database ${operation} failed`, {
      code: 'DATABASE_OPERATION_FAILED',
      userMessage: '数据处理出现问题，我们正在修复',
      retryable: true,
      solutions: ['稍后重试', '清除浏览器缓存', '联系技术支持'],
      cause,
      context: { operation },
    }),

  externalApi: (service: string, statusCode?: number, cause?: Error) =>
    new AppError(ErrorType.EXTERNAL_API_ERROR, `${service} API failed`, {
      code: 'EXTERNAL_API_FAILED',
      userMessage: '外部服务暂时不可用',
      retryable: true,
      solutions: ['稍后重试', '检查网络连接', '联系技术支持'],
      cause,
      context: { service, externalStatusCode: statusCode },
    }),

  businessLogic: (operation: string, reason: string) =>
    new AppError(ErrorType.BUSINESS_LOGIC_ERROR, reason, {
      code: 'BUSINESS_LOGIC_VIOLATION',
      userMessage: reason,
      solutions: ['检查业务规则', '确认操作条件', '联系业务支持'],
      context: { operation },
    }),
};
```

## 错误处理中间件

### Next.js错误边界
```typescript
// src/components/common/ErrorBoundary/ErrorBoundary.tsx
'use client';

import React, { ErrorInfo, ReactNode } from 'react';
import { AppError, ErrorType } from '@/lib/errors/AppError';
import { logger } from '@/lib/logging/logger';
import { Button } from '@/components/ui/Button';

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error | AppError;
  errorId?: string;
}

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: React.ComponentType<{ error: Error; errorId: string; retry: () => void }>;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
}

export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    const errorId = `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    return {
      hasError: true,
      error,
      errorId,
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // 记录错误到日志系统
    logger.error('Error caught by ErrorBoundary', error, {
      errorInfo,
      errorId: this.state.errorId,
      componentStack: errorInfo.componentStack,
    });

    // 调用自定义错误处理器
    this.props.onError?.(error, errorInfo);

    // 发送到错误监控服务
    this.reportErrorToService(error, errorInfo);
  }

  private reportErrorToService(error: Error, errorInfo: ErrorInfo) {
    // 发送到Sentry或其他监控服务
    if (typeof window !== 'undefined' && window.Sentry) {
      window.Sentry.captureException(error, {
        contexts: {
          react: {
            componentStack: errorInfo.componentStack,
          },
        },
        extra: {
          errorId: this.state.errorId,
        },
      });
    }
  }

  private handleRetry = () => {
    this.setState({ hasError: false, error: undefined, errorId: undefined });
  };

  render() {
    if (this.state.hasError && this.state.error) {
      // 使用自定义fallback组件
      if (this.props.fallback) {
        const FallbackComponent = this.props.fallback;
        return (
          <FallbackComponent
            error={this.state.error}
            errorId={this.state.errorId!}
            retry={this.handleRetry}
          />
        );
      }

      // 默认错误UI
      return <DefaultErrorFallback error={this.state.error} retry={this.handleRetry} />;
    }

    return this.props.children;
  }
}

// 默认错误回退组件
function DefaultErrorFallback({ error, retry }: { error: Error; retry: () => void }) {
  const isAppError = error instanceof AppError;
  
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full bg-white rounded-lg shadow-lg p-6">
        <div className="flex items-center justify-center w-12 h-12 mx-auto mb-4 bg-red-100 rounded-full">
          <svg
            className="w-6 h-6 text-red-600"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.996-.833-2.464 0L3.34 16.5c-.77.833.192 2.5 1.732 2.5z"
            />
          </svg>
        </div>
        
        <div className="text-center">
          <h1 className="text-lg font-semibold text-gray-900 mb-2">
            页面出现错误
          </h1>
          
          <p className="text-sm text-gray-600 mb-6">
            {isAppError ? error.userMessage || error.message : '页面加载时发生了未知错误，请重试或联系技术支持。'}
          </p>
          
          {isAppError && error.solutions && (
            <div className="text-left mb-6">
              <p className="text-sm font-medium text-gray-700 mb-2">建议解决方案：</p>
              <ul className="text-sm text-gray-600 space-y-1">
                {error.solutions.map((solution, index) => (
                  <li key={index} className="flex items-start">
                    <span className="mr-2">•</span>
                    <span>{solution}</span>
                  </li>
                ))}
              </ul>
            </div>
          )}
          
          <div className="flex flex-col sm:flex-row gap-3">
            <Button onClick={retry} variant="primary" className="flex-1">
              重新加载
            </Button>
            <Button
              onClick={() => window.location.href = '/'}
              variant="secondary"
              className="flex-1"
            >
              返回首页
            </Button>
          </div>
          
          {process.env.NODE_ENV === 'development' && (
            <details className="mt-6 text-left">
              <summary className="text-sm font-medium text-gray-700 cursor-pointer">
                开发者信息
              </summary>
              <pre className="mt-2 text-xs text-gray-600 bg-gray-100 p-3 rounded overflow-auto">
                {error.stack}
              </pre>
            </details>
          )}
        </div>
      </div>
    </div>
  );
}
```

### API错误处理中间件
```typescript
// src/lib/errors/api-error-handler.ts
import { NextRequest, NextResponse } from 'next/server';
import { AppError, ErrorType } from '@/lib/errors/AppError';
import { logger } from '@/lib/logging/logger';

export function withErrorHandler(
  handler: (req: NextRequest, context: any) => Promise<NextResponse>
) {
  return async (req: NextRequest, context: any): Promise<NextResponse> => {
    try {
      return await handler(req, context);
    } catch (error) {
      return handleApiError(error, req);
    }
  };
}

export function handleApiError(error: unknown, req?: NextRequest): NextResponse {
  let appError: AppError;

  // 转换为AppError
  if (error instanceof AppError) {
    appError = error;
  } else if (error instanceof Error) {
    appError = convertToAppError(error, req);
  } else {
    appError = new AppError(
      ErrorType.INTERNAL_SERVER_ERROR,
      'Unknown error occurred',
      {
        context: {
          originalError: String(error),
          url: req?.url,
          method: req?.method,
        },
      }
    );
  }

  // 添加请求上下文
  if (req) {
    appError.context = {
      ...appError.context,
      url: req.url,
      method: req.method,
      userAgent: req.headers.get('user-agent') || undefined,
      ipAddress: getClientIP(req),
      requestId: generateRequestId(),
    };
  }

  // 记录错误
  logError(appError);

  // 发送错误响应
  return NextResponse.json(appError.toJSON(), {
    status: appError.statusCode,
    headers: {
      'Content-Type': 'application/json',
      'X-Request-ID': appError.context.requestId || 'unknown',
    },
  });
}

function convertToAppError(error: Error, req?: NextRequest): AppError {
  // 根据错误类型和消息判断错误类型
  if (error.name === 'ValidationError' || error.message.includes('validation')) {
    return new AppError(ErrorType.VALIDATION_ERROR, error.message, { cause: error });
  }

  if (error.name === 'NotFoundError' || error.message.includes('not found')) {
    return new AppError(ErrorType.NOT_FOUND_ERROR, error.message, { cause: error });
  }

  if (error.name === 'TimeoutError' || error.message.includes('timeout')) {
    return new AppError(ErrorType.TIMEOUT_ERROR, error.message, { 
      cause: error,
      retryable: true,
    });
  }

  if (error.name === 'NetworkError' || error.message.includes('network')) {
    return new AppError(ErrorType.NETWORK_ERROR, error.message, { 
      cause: error,
      retryable: true,
    });
  }

  // 默认为内部服务器错误
  return new AppError(ErrorType.INTERNAL_SERVER_ERROR, error.message, { cause: error });
}

function logError(error: AppError) {
  const logLevel = error.statusCode >= 500 ? 'error' : 'warn';
  
  logger[logLevel](`API Error: ${error.type}`, error.toLogFormat());

  // 对于严重错误，发送告警
  if (error.statusCode >= 500) {
    sendErrorAlert(error);
  }
}

function sendErrorAlert(error: AppError) {
  // 发送到监控系统或告警渠道
  // 这里可以集成钉钉、邮件或其他告警系统
  console.error('Critical error occurred:', error.toLogFormat());
}

function getClientIP(req: NextRequest): string {
  return (
    req.headers.get('x-forwarded-for')?.split(',')[0] ||
    req.headers.get('x-real-ip') ||
    req.headers.get('cf-connecting-ip') ||
    'unknown'
  );
}

function generateRequestId(): string {
  return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}
```

## 用户友好错误页面

### 404页面设计
```typescript
// src/app/not-found.tsx
import Link from 'next/link';
import { Button } from '@/components/ui/Button';
import { SearchBar } from '@/components/features/SearchBar';

export default function NotFound() {
  return (
    <div className="min-h-screen bg-gradient-to-b from-gray-50 to-gray-100">
      <div className="container mx-auto px-4 py-16">
        <div className="max-w-2xl mx-auto text-center">
          {/* 404 图标 */}
          <div className="mb-8">
            <svg
              className="mx-auto w-24 h-24 text-gray-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={1}
                d="M9.172 16.172a4 4 0 015.656 0M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
              />
            </svg>
          </div>

          {/* 错误信息 */}
          <div className="mb-8">
            <h1 className="text-6xl font-bold text-gray-900 mb-4">404</h1>
            <h2 className="text-2xl font-semibold text-gray-700 mb-4">
              页面未找到
            </h2>
            <p className="text-gray-600 mb-8">
              抱歉，您访问的页面不存在或已被移动。让我们帮您找到需要的内容。
            </p>
          </div>

          {/* 搜索建议 */}
          <div className="mb-8">
            <h3 className="text-lg font-medium text-gray-900 mb-4">
              搜索您需要的产品：
            </h3>
            <SearchBar 
              placeholder="输入产品型号或关键词..."
              className="max-w-md mx-auto"
            />
          </div>

          {/* 快速链接 */}
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
            <Link href="/brands" className="group">
              <div className="p-4 border rounded-lg hover:shadow-md transition-shadow">
                <div className="w-8 h-8 mx-auto mb-2 text-primary-600">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
                  </svg>
                </div>
                <h4 className="font-medium text-gray-900 group-hover:text-primary-600">
                  品牌中心
                </h4>
                <p className="text-sm text-gray-500">
                  浏览所有品牌产品
                </p>
              </div>
            </Link>

            <Link href="/products" className="group">
              <div className="p-4 border rounded-lg hover:shadow-md transition-shadow">
                <div className="w-8 h-8 mx-auto mb-2 text-primary-600">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4" />
                  </svg>
                </div>
                <h4 className="font-medium text-gray-900 group-hover:text-primary-600">
                  产品分类
                </h4>
                <p className="text-sm text-gray-500">
                  按类别查找产品
                </p>
              </div>
            </Link>

            <Link href="/about" className="group">
              <div className="p-4 border rounded-lg hover:shadow-md transition-shadow">
                <div className="w-8 h-8 mx-auto mb-2 text-primary-600">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                </div>
                <h4 className="font-medium text-gray-900 group-hover:text-primary-600">
                  技术支持
                </h4>
                <p className="text-sm text-gray-500">
                  获取专业帮助
                </p>
              </div>
            </Link>
          </div>

          {/* 行动按钮 */}
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Button asChild variant="primary">
              <Link href="/">返回首页</Link>
            </Button>
            <Button asChild variant="secondary">
              <Link href="/contact">联系客服</Link>
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}
```

### 全局错误页面
```typescript
// src/app/error.tsx
'use client';

import { useEffect } from 'react';
import { Button } from '@/components/ui/Button';

interface ErrorProps {
  error: Error & { digest?: string };
  reset: () => void;
}

export default function Error({ error, reset }: ErrorProps) {
  useEffect(() => {
    // 记录错误到监控服务
    console.error('Global error:', error);
  }, [error]);

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col justify-center">
      <div className="max-w-md mx-auto bg-white rounded-lg shadow-lg p-8">
        <div className="text-center">
          {/* 错误图标 */}
          <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100 mb-4">
            <svg
              className="h-6 w-6 text-red-600"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.996-.833-2.464 0L3.34 16.5c-.77.833.192 2.5 1.732 2.5z"
              />
            </svg>
          </div>

          <h2 className="text-lg font-medium text-gray-900 mb-2">
            出现了一些问题
          </h2>
          
          <p className="text-sm text-gray-600 mb-6">
            页面加载时发生错误，请尝试刷新页面或联系技术支持。
          </p>

          {/* 错误ID */}
          {error.digest && (
            <div className="mb-6 p-3 bg-gray-100 rounded text-xs text-gray-500">
              错误ID: {error.digest}
            </div>
          )}

          <div className="flex flex-col sm:flex-row gap-3">
            <Button onClick={reset} variant="primary" className="flex-1">
              重试
            </Button>
            <Button
              onClick={() => window.location.href = '/'}
              variant="secondary"
              className="flex-1"
            >
              返回首页
            </Button>
          </div>

          {/* 联系信息 */}
          <div className="mt-6 pt-6 border-t border-gray-200 text-xs text-gray-500">
            <p>如果问题持续存在，请联系技术支持：</p>
            <p className="mt-1">
              <a href="mailto:support@elec-distributor.com" className="text-primary-600 hover:text-primary-700">
                support@elec-distributor.com
              </a>
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
```

## 重试机制设计

### 指数退避重试
```typescript
// src/lib/utils/retry.ts
interface RetryOptions {
  maxAttempts: number;
  baseDelay: number;
  maxDelay: number;
  backoffFactor: number;
  retryCondition?: (error: any) => boolean;
  onRetry?: (attempt: number, error: any) => void;
}

const defaultRetryOptions: RetryOptions = {
  maxAttempts: 3,
  baseDelay: 1000,
  maxDelay: 30000,
  backoffFactor: 2,
  retryCondition: (error) => {
    // 默认只重试网络错误和5xx错误
    if (error instanceof AppError) {
      return error.retryable;
    }
    
    // 检查HTTP状态码
    if (error?.status) {
      return error.status >= 500 || error.status === 408 || error.status === 429;
    }
    
    return false;
  },
};

export async function withRetry<T>(
  operation: () => Promise<T>,
  options: Partial<RetryOptions> = {}
): Promise<T> {
  const config = { ...defaultRetryOptions, ...options };
  
  let lastError: any;
  
  for (let attempt = 1; attempt <= config.maxAttempts; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      
      // 检查是否应该重试
      if (attempt === config.maxAttempts || !config.retryCondition!(error)) {
        throw error;
      }
      
      // 调用重试回调
      config.onRetry?.(attempt, error);
      
      // 计算延迟时间（指数退避）
      const delay = Math.min(
        config.baseDelay * Math.pow(config.backoffFactor, attempt - 1),
        config.maxDelay
      );
      
      // 添加随机抖动
      const jitter = Math.random() * 0.1 * delay;
      const actualDelay = delay + jitter;
      
      await new Promise(resolve => setTimeout(resolve, actualDelay));
    }
  }
  
  throw lastError;
}

// 使用示例
export async function fetchWithRetry<T>(
  url: string,
  options: RequestInit = {}
): Promise<T> {
  return withRetry(
    async () => {
      const response = await fetch(url, options);
      
      if (!response.ok) {
        throw new AppError(
          response.status >= 500 
            ? ErrorType.EXTERNAL_API_ERROR 
            : ErrorType.VALIDATION_ERROR,
          `HTTP ${response.status}: ${response.statusText}`,
          {
            statusCode: response.status,
            retryable: response.status >= 500,
            context: { url, method: options.method || 'GET' },
          }
        );
      }
      
      return response.json();
    },
    {
      onRetry: (attempt, error) => {
        logger.warn(`Retrying request to ${url}, attempt ${attempt}`, { error: error.message });
      },
    }
  );
}
```

### 断路器模式
```typescript
// src/lib/patterns/circuit-breaker.ts
enum CircuitState {
  CLOSED = 'CLOSED',
  OPEN = 'OPEN',
  HALF_OPEN = 'HALF_OPEN',
}

interface CircuitBreakerOptions {
  failureThreshold: number;
  recoveryTimeout: number;
  monitoringPeriod: number;
  expectedErrors?: (error: any) => boolean;
}

export class CircuitBreaker {
  private state: CircuitState = CircuitState.CLOSED;
  private failureCount = 0;
  private lastFailureTime = 0;
  private successCount = 0;

  constructor(private options: CircuitBreakerOptions) {}

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === CircuitState.OPEN) {
      if (this.shouldAttemptReset()) {
        this.state = CircuitState.HALF_OPEN;
      } else {
        throw new AppError(
          ErrorType.RESOURCE_EXHAUSTED_ERROR,
          'Circuit breaker is open',
          {
            code: 'CIRCUIT_BREAKER_OPEN',
            userMessage: '服务暂时不可用，请稍后重试',
            retryable: true,
            solutions: [
              `请等待 ${Math.ceil(this.getRemainingTimeout() / 1000)} 秒后重试`,
              '检查网络连接',
              '联系技术支持',
            ],
          }
        );
      }
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure(error);
      throw error;
    }
  }

  private shouldAttemptReset(): boolean {
    return Date.now() - this.lastFailureTime >= this.options.recoveryTimeout;
  }

  private getRemainingTimeout(): number {
    return Math.max(
      0,
      this.options.recoveryTimeout - (Date.now() - this.lastFailureTime)
    );
  }

  private onSuccess(): void {
    this.failureCount = 0;
    
    if (this.state === CircuitState.HALF_OPEN) {
      this.successCount++;
      if (this.successCount >= 3) { // 需要连续3次成功才关闭断路器
        this.state = CircuitState.CLOSED;
        this.successCount = 0;
      }
    }
  }

  private onFailure(error: any): void {
    if (this.options.expectedErrors && !this.options.expectedErrors(error)) {
      return; // 不是预期的错误，不计入失败计数
    }

    this.failureCount++;
    this.lastFailureTime = Date.now();
    this.successCount = 0;

    if (this.failureCount >= this.options.failureThreshold) {
      this.state = CircuitState.OPEN;
    }
  }

  getState(): CircuitState {
    return this.state;
  }

  getMetrics() {
    return {
      state: this.state,
      failureCount: this.failureCount,
      lastFailureTime: this.lastFailureTime,
      successCount: this.successCount,
    };
  }
}

// 使用示例
const sanityCircuitBreaker = new CircuitBreaker({
  failureThreshold: 5,
  recoveryTimeout: 30000, // 30秒
  monitoringPeriod: 60000, // 1分钟
  expectedErrors: (error) => {
    return error instanceof AppError && error.type === ErrorType.EXTERNAL_API_ERROR;
  },
});

export async function fetchSanityData<T>(query: string): Promise<T> {
  return sanityCircuitBreaker.execute(async () => {
    return client.fetch(query);
  });
}
```